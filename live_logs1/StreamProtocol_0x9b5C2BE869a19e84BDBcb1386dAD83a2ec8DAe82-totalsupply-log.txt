This is Ultimate 0.1.24-f1553f5-m
[2020-11-25 05:48:34,976 INFO  L170        SettingsManager]: Resetting all preferences to default values...
[2020-11-25 05:48:34,978 INFO  L174        SettingsManager]: Resetting UltimateCore preferences to default values
[2020-11-25 05:48:34,991 INFO  L177        SettingsManager]: Ultimate Commandline Interface provides no preferences, ignoring...
[2020-11-25 05:48:34,992 INFO  L174        SettingsManager]: Resetting Boogie Preprocessor preferences to default values
[2020-11-25 05:48:34,992 INFO  L174        SettingsManager]: Resetting Boogie Procedure Inliner preferences to default values
[2020-11-25 05:48:34,993 INFO  L174        SettingsManager]: Resetting Abstract Interpretation preferences to default values
[2020-11-25 05:48:34,995 INFO  L174        SettingsManager]: Resetting LassoRanker preferences to default values
[2020-11-25 05:48:34,997 INFO  L174        SettingsManager]: Resetting Reaching Definitions preferences to default values
[2020-11-25 05:48:34,998 INFO  L174        SettingsManager]: Resetting SyntaxChecker preferences to default values
[2020-11-25 05:48:34,998 INFO  L177        SettingsManager]: BÃ¼chi Program Product provides no preferences, ignoring...
[2020-11-25 05:48:34,999 INFO  L174        SettingsManager]: Resetting LTL2Aut preferences to default values
[2020-11-25 05:48:34,999 INFO  L174        SettingsManager]: Resetting PEA to Boogie preferences to default values
[2020-11-25 05:48:35,000 INFO  L174        SettingsManager]: Resetting BlockEncodingV2 preferences to default values
[2020-11-25 05:48:35,001 INFO  L174        SettingsManager]: Resetting ChcToBoogie preferences to default values
[2020-11-25 05:48:35,002 INFO  L174        SettingsManager]: Resetting AutomataScriptInterpreter preferences to default values
[2020-11-25 05:48:35,003 INFO  L174        SettingsManager]: Resetting BuchiAutomizer preferences to default values
[2020-11-25 05:48:35,005 INFO  L174        SettingsManager]: Resetting CACSL2BoogieTranslator preferences to default values
[2020-11-25 05:48:35,007 INFO  L174        SettingsManager]: Resetting CodeCheck preferences to default values
[2020-11-25 05:48:35,008 INFO  L174        SettingsManager]: Resetting InvariantSynthesis preferences to default values
[2020-11-25 05:48:35,008 INFO  L174        SettingsManager]: Resetting RCFGBuilder preferences to default values
[2020-11-25 05:48:35,009 INFO  L174        SettingsManager]: Resetting TraceAbstraction preferences to default values
[2020-11-25 05:48:35,011 INFO  L177        SettingsManager]: TraceAbstractionConcurrent provides no preferences, ignoring...
[2020-11-25 05:48:35,012 INFO  L177        SettingsManager]: TraceAbstractionWithAFAs provides no preferences, ignoring...
[2020-11-25 05:48:35,012 INFO  L174        SettingsManager]: Resetting TreeAutomizer preferences to default values
[2020-11-25 05:48:35,012 INFO  L174        SettingsManager]: Resetting IcfgToChc preferences to default values
[2020-11-25 05:48:35,013 INFO  L174        SettingsManager]: Resetting IcfgTransformer preferences to default values
[2020-11-25 05:48:35,013 INFO  L177        SettingsManager]: ReqToTest provides no preferences, ignoring...
[2020-11-25 05:48:35,013 INFO  L174        SettingsManager]: Resetting UtopiaLTL2Aut preferences to default values
[2020-11-25 05:48:35,014 INFO  L174        SettingsManager]: Resetting UtopiaSpecLang preferences to default values
[2020-11-25 05:48:35,014 INFO  L174        SettingsManager]: Resetting Boogie Printer preferences to default values
[2020-11-25 05:48:35,015 INFO  L174        SettingsManager]: Resetting ChcSmtPrinter preferences to default values
[2020-11-25 05:48:35,015 INFO  L174        SettingsManager]: Resetting ReqPrinter preferences to default values
[2020-11-25 05:48:35,016 INFO  L174        SettingsManager]: Resetting Witness Printer preferences to default values
[2020-11-25 05:48:35,017 INFO  L177        SettingsManager]: Boogie PL CUP Parser provides no preferences, ignoring...
[2020-11-25 05:48:35,017 INFO  L174        SettingsManager]: Resetting CDTParser preferences to default values
[2020-11-25 05:48:35,017 INFO  L177        SettingsManager]: AutomataScriptParser provides no preferences, ignoring...
[2020-11-25 05:48:35,017 INFO  L177        SettingsManager]: ReqParser provides no preferences, ignoring...
[2020-11-25 05:48:35,017 INFO  L174        SettingsManager]: Resetting SmtParser preferences to default values
[2020-11-25 05:48:35,018 INFO  L174        SettingsManager]: Resetting Witness Parser preferences to default values
[2020-11-25 05:48:35,019 INFO  L181        SettingsManager]: Finished resetting all preferences to default values...
[2020-11-25 05:48:35,019 INFO  L98         SettingsManager]: Beginning loading settings from /mnt/data0/jon/SmartPulseTool/SmartPulse/settings.epf
[2020-11-25 05:48:35,029 INFO  L110        SettingsManager]: Loading preferences was successful
[2020-11-25 05:48:35,029 INFO  L112        SettingsManager]: Preferences different from defaults after loading the file:
[2020-11-25 05:48:35,030 INFO  L131        SettingsManager]: Preferences of LTL2Aut differ from their defaults:
[2020-11-25 05:48:35,030 INFO  L133        SettingsManager]:  * Read property from file=true
[2020-11-25 05:48:35,030 INFO  L133        SettingsManager]:  * Path to LTL*BA executable (LTL2BA, LTL3BA)=/mnt/data0/jon/SmartPulseTool/ltl2ba
[2020-11-25 05:48:35,031 INFO  L131        SettingsManager]: Preferences of BlockEncodingV2 differ from their defaults:
[2020-11-25 05:48:35,031 INFO  L133        SettingsManager]:  * Maximize final states=false
[2020-11-25 05:48:35,031 INFO  L133        SettingsManager]:  * Minimize states even if more edges are added than removed.=true
[2020-11-25 05:48:35,031 INFO  L133        SettingsManager]:  * Minimize states using LBE with the strategy=NONE
[2020-11-25 05:48:35,031 INFO  L131        SettingsManager]: Preferences of BuchiAutomizer differ from their defaults:
[2020-11-25 05:48:35,031 INFO  L133        SettingsManager]:  * Compute Interpolants along a Counterexample=Craig_TreeInterpolation
[2020-11-25 05:48:35,031 INFO  L133        SettingsManager]:  * Use old map elimination=false
[2020-11-25 05:48:35,031 INFO  L133        SettingsManager]:  * Try twofold refinement=false
[2020-11-25 05:48:35,031 INFO  L131        SettingsManager]: Preferences of CACSL2BoogieTranslator differ from their defaults:
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * Check unreachability of error function in SV-COMP mode=false
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * Overapproximate operations on floating types=true
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * Check division by zero=IGNORE
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * Pointer to allocated memory at dereference=ASSUME
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * If two pointers are subtracted or compared they have the same base address=ASSUME
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * Check array bounds for arrays that are off heap=ASSUME
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * Check if freed pointer was valid=false
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * Use constant arrays=true
[2020-11-25 05:48:35,032 INFO  L133        SettingsManager]:  * Pointer base address is valid at dereference=ASSUME
[2020-11-25 05:48:35,033 INFO  L131        SettingsManager]: Preferences of RCFGBuilder differ from their defaults:
[2020-11-25 05:48:35,033 INFO  L133        SettingsManager]:  * Size of a code block=SingleStatement
[2020-11-25 05:48:35,033 INFO  L133        SettingsManager]:  * SMT solver=Internal_SMTInterpol
[2020-11-25 05:48:35,057 INFO  L81    nceAwareModelManager]: Repository-Root is: /tmp
[2020-11-25 05:48:35,069 INFO  L259   ainManager$Toolchain]: [Toolchain 1]: Applicable parser(s) successfully (re)initialized
[2020-11-25 05:48:35,071 INFO  L215   ainManager$Toolchain]: [Toolchain 1]: Toolchain selected.
[2020-11-25 05:48:35,072 INFO  L271        PluginConnector]: Initializing Boogie PL CUP Parser...
[2020-11-25 05:48:35,073 INFO  L276        PluginConnector]: Boogie PL CUP Parser initialized
[2020-11-25 05:48:35,073 INFO  L430   ainManager$Toolchain]: [Toolchain 1]: Parsing single file: /mnt/data0/jon/SmartPulseTool/StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl
[2020-11-25 05:48:35,073 INFO  L111           BoogieParser]: Parsing: '/mnt/data0/jon/SmartPulseTool/StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl'
[2020-11-25 05:48:35,150 INFO  L297   ainManager$Toolchain]: ####################### [Toolchain 1] #######################
[2020-11-25 05:48:35,152 INFO  L131        ToolchainWalker]: Walking toolchain with 8 elements.
[2020-11-25 05:48:35,152 INFO  L113        PluginConnector]: ------------------------Boogie Preprocessor----------------------------
[2020-11-25 05:48:35,152 INFO  L271        PluginConnector]: Initializing Boogie Preprocessor...
[2020-11-25 05:48:35,152 INFO  L276        PluginConnector]: Boogie Preprocessor initialized
[2020-11-25 05:48:35,169 INFO  L185        PluginConnector]: Executing the observer EnsureBoogieModelObserver from plugin Boogie Preprocessor for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/1) ...
[2020-11-25 05:48:35,171 INFO  L185        PluginConnector]: Executing the observer TypeChecker from plugin Boogie Preprocessor for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/1) ...
[2020-11-25 05:48:35,206 INFO  L185        PluginConnector]: Executing the observer ConstExpander from plugin Boogie Preprocessor for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/1) ...
[2020-11-25 05:48:35,206 INFO  L185        PluginConnector]: Executing the observer StructExpander from plugin Boogie Preprocessor for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/1) ...
[2020-11-25 05:48:35,228 INFO  L185        PluginConnector]: Executing the observer UnstructureCode from plugin Boogie Preprocessor for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/1) ...
[2020-11-25 05:48:35,237 INFO  L185        PluginConnector]: Executing the observer FunctionInliner from plugin Boogie Preprocessor for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/1) ...
[2020-11-25 05:48:35,244 INFO  L185        PluginConnector]: Executing the observer BoogieSymbolTableConstructor from plugin Boogie Preprocessor for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/1) ...
[2020-11-25 05:48:35,253 INFO  L132        PluginConnector]: ------------------------ END Boogie Preprocessor----------------------------
[2020-11-25 05:48:35,253 INFO  L113        PluginConnector]: ------------------------UtopiaSpecLang----------------------------
[2020-11-25 05:48:35,253 INFO  L271        PluginConnector]: Initializing UtopiaSpecLang...
[2020-11-25 05:48:35,255 INFO  L276        PluginConnector]: UtopiaSpecLang initialized
[2020-11-25 05:48:35,259 INFO  L185        PluginConnector]: Executing the observer UtopiaSpecLangObserver from plugin UtopiaSpecLang for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/1) ...
[2020-11-25 05:48:35,278 INFO  L1012  opiaSpecLangObserver]: Parsing LTLPlus Formula to AstNode: [](started(StreamProtocol.totalSupply, _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 0x10000000000000000000000000000000000000000000000000000000000000000) ==> <>(finished(StreamProtocol.totalSupply, return == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this]) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this]) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this]) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this]) && name_StreamProtocol[this] == old(name_StreamProtocol[this]) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this]) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this]) && owner_Owned[this] == old(owner_Owned[this]))))
[2020-11-25 05:48:35,283 INFO  L1016  opiaSpecLangObserver]: Successfully lexed: [](started(StreamProtocol.totalSupply, _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 0x10000000000000000000000000000000000000000000000000000000000000000) ==> <>(finished(StreamProtocol.totalSupply, return == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this]) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this]) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this]) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this]) && name_StreamProtocol[this] == old(name_StreamProtocol[this]) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this]) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this]) && owner_Owned[this] == old(owner_Owned[this]))))
[2020-11-25 05:48:35,290 INFO  L1018  opiaSpecLangObserver]: Successfully parsed: [](started(StreamProtocol.totalSupply, _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 0x10000000000000000000000000000000000000000000000000000000000000000) ==> <>(finished(StreamProtocol.totalSupply, return == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this]) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this]) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this]) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this]) && name_StreamProtocol[this] == old(name_StreamProtocol[this]) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this]) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this]) && owner_Owned[this] == old(owner_Owned[this]))))
[2020-11-25 05:48:35,296 INFO  L636   opiaSpecLangObserver]: Parsed ( _totalSupply_StreamProtocol[this]>=0 && _totalSupply_StreamProtocol[this]<115792089237316195423570985008687907853269984665640564039457584007913129639936 ) to BinaryExpression[LOGICAND,BinaryExpression[COMPGEQ,ArrayAccessExpression[IdentifierExpression[_totalSupply_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],IntegerLiteral[0]],BinaryExpression[COMPLT,ArrayAccessExpression[IdentifierExpression[_totalSupply_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],IntegerLiteral[115792089237316195423570985008687907853269984665640564039457584007913129639936]]]
[2020-11-25 05:48:35,299 INFO  L636   opiaSpecLangObserver]: Parsed ( ( ( ( ( ( ( ( __ret_0_==_totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this]==( old(_totalSupply_StreamProtocol[this]) ) ) && balances_StreamProtocol[this]==( old(balances_StreamProtocol[this]) ) ) && allowed_StreamProtocol[this]==( old(allowed_StreamProtocol[this]) ) ) && symbol_StreamProtocol[this]==( old(symbol_StreamProtocol[this]) ) ) && name_StreamProtocol[this]==( old(name_StreamProtocol[this]) ) ) && decimals_StreamProtocol[this]==( old(decimals_StreamProtocol[this]) ) ) && _stopTrade_StreamProtocol[this]==( old(_stopTrade_StreamProtocol[this]) ) ) && owner_Owned[this]==( old(owner_Owned[this]) ) ) to BinaryExpression[LOGICAND,BinaryExpression[LOGICAND,BinaryExpression[LOGICAND,BinaryExpression[LOGICAND,BinaryExpression[LOGICAND,BinaryExpression[LOGICAND,BinaryExpression[LOGICAND,BinaryExpression[LOGICAND,BinaryExpression[COMPEQ,IdentifierExpression[__ret_0_,<IMPLEMENTATION_OUTPARAM,totalSupply_StreamProtocol>],ArrayAccessExpression[IdentifierExpression[_totalSupply_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]],BinaryExpression[COMPEQ,ArrayAccessExpression[IdentifierExpression[_totalSupply_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],UnaryExpression[OLD,ArrayAccessExpression[IdentifierExpression[_totalSupply_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]]]],BinaryExpression[COMPEQ,ArrayAccessExpression[IdentifierExpression[balances_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],UnaryExpression[OLD,ArrayAccessExpression[IdentifierExpression[balances_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]]]],BinaryExpression[COMPEQ,ArrayAccessExpression[IdentifierExpression[allowed_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],UnaryExpression[OLD,ArrayAccessExpression[IdentifierExpression[allowed_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]]]],BinaryExpression[COMPEQ,ArrayAccessExpression[IdentifierExpression[symbol_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],UnaryExpression[OLD,ArrayAccessExpression[IdentifierExpression[symbol_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]]]],BinaryExpression[COMPEQ,ArrayAccessExpression[IdentifierExpression[name_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],UnaryExpression[OLD,ArrayAccessExpression[IdentifierExpression[name_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]]]],BinaryExpression[COMPEQ,ArrayAccessExpression[IdentifierExpression[decimals_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],UnaryExpression[OLD,ArrayAccessExpression[IdentifierExpression[decimals_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]]]],BinaryExpression[COMPEQ,ArrayAccessExpression[IdentifierExpression[_stopTrade_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],UnaryExpression[OLD,ArrayAccessExpression[IdentifierExpression[_stopTrade_StreamProtocol,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]]]],BinaryExpression[COMPEQ,ArrayAccessExpression[IdentifierExpression[owner_Owned,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]],UnaryExpression[OLD,ArrayAccessExpression[IdentifierExpression[owner_Owned,GLOBAL],[IdentifierExpression[this,<IMPLEMENTATION_INPARAM,totalSupply_StreamProtocol>]]]]]]
[2020-11-25 05:48:35,304 INFO  L1005  opiaSpecLangObserver]: Compiling: [](started(StreamProtocol.totalSupply, _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 0x10000000000000000000000000000000000000000000000000000000000000000) ==> <>(finished(StreamProtocol.totalSupply, return == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this]) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this]) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this]) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this]) && name_StreamProtocol[this] == old(name_StreamProtocol[this]) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this]) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this]) && owner_Owned[this] == old(owner_Owned[this]))))
[2020-11-25 05:48:35,304 INFO  L1007  opiaSpecLangObserver]: Compiled to ( []( AP(call_totalSupply_StreamProtocol0) ==> ( <>AP(success_totalSupply_StreamProtocol0) ) ) )
Executed UtopiaSpecLang
[2020-11-25 05:48:35,312 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.specLang AST 25.11 05:48:35 PropertyContainer
[2020-11-25 05:48:35,312 INFO  L132        PluginConnector]: ------------------------ END UtopiaSpecLang----------------------------
[2020-11-25 05:48:35,312 INFO  L113        PluginConnector]: ------------------------Boogie Printer----------------------------
[2020-11-25 05:48:35,312 INFO  L271        PluginConnector]: Initializing Boogie Printer...
[2020-11-25 05:48:35,312 INFO  L276        PluginConnector]: Boogie Printer initialized
[2020-11-25 05:48:35,313 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/2) ...
[2020-11-25 05:48:35,313 INFO  L116   oogiePrinterObserver]: File already exists and will be overwritten: /tmp/boogiePrinter.bpl
[2020-11-25 05:48:35,314 INFO  L120   oogiePrinterObserver]: Writing to file /tmp/boogiePrinter.bpl
[2020-11-25 05:48:35,326 INFO  L185        PluginConnector]: Executing the observer BoogiePrinterObserver from plugin Boogie Printer for "Hardcoded edu.utexas.cs.utopia.specLang AST 25.11 05:48:35" (2/2) ...
[2020-11-25 05:48:35,326 INFO  L132        PluginConnector]: ------------------------ END Boogie Printer----------------------------
[2020-11-25 05:48:35,326 INFO  L113        PluginConnector]: ------------------------RCFGBuilder----------------------------
[2020-11-25 05:48:35,326 INFO  L271        PluginConnector]: Initializing RCFGBuilder...
[2020-11-25 05:48:35,326 INFO  L276        PluginConnector]: RCFGBuilder initialized
[2020-11-25 05:48:35,327 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/2) ...
[2020-11-25 05:48:35,379 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__success
[2020-11-25 05:48:35,380 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-11-25 05:48:35,380 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath
[2020-11-25 05:48:35,380 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath
[2020-11-25 05:48:35,380 INFO  L130     BoogieDeclarations]: Found specification of procedure add~uint256~uint256_SafeMath__success
[2020-11-25 05:48:35,380 INFO  L130     BoogieDeclarations]: Found specification of procedure sub~uint256~uint256_SafeMath__success
[2020-11-25 05:48:35,380 INFO  L130     BoogieDeclarations]: Found specification of procedure mul~uint256~uint256_SafeMath__success
[2020-11-25 05:48:35,380 INFO  L130     BoogieDeclarations]: Found specification of procedure div~uint256~uint256_SafeMath__success
[2020-11-25 05:48:35,380 INFO  L130     BoogieDeclarations]: Found specification of procedure ERC20Interface_ERC20Interface_NoBaseCtor__success
[2020-11-25 05:48:35,380 INFO  L130     BoogieDeclarations]: Found specification of procedure ERC20Interface_ERC20Interface
[2020-11-25 05:48:35,380 INFO  L138     BoogieDeclarations]: Found implementation of procedure ERC20Interface_ERC20Interface
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure totalSupply_ERC20Interface
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure balanceOf~address_ERC20Interface
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure allowance~address~address_ERC20Interface
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure transfer~address~uint256_ERC20Interface
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure approve~address~uint256_ERC20Interface
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure transferFrom~address~address~uint256_ERC20Interface
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure ApproveAndCallFallBack_ApproveAndCallFallBack_NoBaseCtor__success
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure ApproveAndCallFallBack_ApproveAndCallFallBack
[2020-11-25 05:48:35,381 INFO  L138     BoogieDeclarations]: Found implementation of procedure ApproveAndCallFallBack_ApproveAndCallFallBack
[2020-11-25 05:48:35,381 INFO  L130     BoogieDeclarations]: Found specification of procedure receiveApproval~address~uint256~address~bytes_ApproveAndCallFallBack
[2020-11-25 05:48:35,382 INFO  L130     BoogieDeclarations]: Found specification of procedure Owned_Owned_NoBaseCtor__success
[2020-11-25 05:48:35,382 INFO  L130     BoogieDeclarations]: Found specification of procedure Owned_Owned
[2020-11-25 05:48:35,382 INFO  L138     BoogieDeclarations]: Found implementation of procedure Owned_Owned
[2020-11-25 05:48:35,382 INFO  L130     BoogieDeclarations]: Found specification of procedure owner_Owned
[2020-11-25 05:48:35,382 INFO  L138     BoogieDeclarations]: Found implementation of procedure owner_Owned
[2020-11-25 05:48:35,382 INFO  L130     BoogieDeclarations]: Found specification of procedure StreamProtocol_StreamProtocol_NoBaseCtor__success
[2020-11-25 05:48:35,382 INFO  L130     BoogieDeclarations]: Found specification of procedure StreamProtocol_StreamProtocol
[2020-11-25 05:48:35,382 INFO  L138     BoogieDeclarations]: Found implementation of procedure StreamProtocol_StreamProtocol
[2020-11-25 05:48:35,382 INFO  L130     BoogieDeclarations]: Found specification of procedure totalSupply_StreamProtocol
[2020-11-25 05:48:35,382 INFO  L138     BoogieDeclarations]: Found implementation of procedure totalSupply_StreamProtocol
[2020-11-25 05:48:35,382 INFO  L130     BoogieDeclarations]: Found specification of procedure stopTrade_StreamProtocol
[2020-11-25 05:48:35,382 INFO  L138     BoogieDeclarations]: Found implementation of procedure stopTrade_StreamProtocol
[2020-11-25 05:48:35,382 INFO  L130     BoogieDeclarations]: Found specification of procedure startTrade_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L138     BoogieDeclarations]: Found implementation of procedure startTrade_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L130     BoogieDeclarations]: Found specification of procedure balanceOf~address_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L138     BoogieDeclarations]: Found implementation of procedure balanceOf~address_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L130     BoogieDeclarations]: Found specification of procedure transfer~address~uint256_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L138     BoogieDeclarations]: Found implementation of procedure transfer~address~uint256_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L130     BoogieDeclarations]: Found specification of procedure approve~address~uint256_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L138     BoogieDeclarations]: Found implementation of procedure approve~address~uint256_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L130     BoogieDeclarations]: Found specification of procedure transferFrom~address~address~uint256_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferFrom~address~address~uint256_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L130     BoogieDeclarations]: Found specification of procedure allowance~address~address_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L138     BoogieDeclarations]: Found implementation of procedure allowance~address~address_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L130     BoogieDeclarations]: Found specification of procedure approveAndCall~address~uint256~bytes_StreamProtocol
[2020-11-25 05:48:35,383 INFO  L138     BoogieDeclarations]: Found implementation of procedure approveAndCall~address~uint256~bytes_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackMethod_StreamProtocol__success
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure transferAnyERC20Token~address~uint256_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferAnyERC20Token~address~uint256_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure burn~uint256_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L138     BoogieDeclarations]: Found implementation of procedure burn~uint256_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure symbol_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L138     BoogieDeclarations]: Found implementation of procedure symbol_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure name_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L138     BoogieDeclarations]: Found implementation of procedure name_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure decimals_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L138     BoogieDeclarations]: Found implementation of procedure decimals_StreamProtocol
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__success
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__success
[2020-11-25 05:48:35,384 INFO  L130     BoogieDeclarations]: Found specification of procedure send__success
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyOwner_pre__success
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_SafeMath
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_SafeMath
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_ERC20Interface
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_ERC20Interface
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_ApproveAndCallFallBack
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_ApproveAndCallFallBack
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_Owned
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralEntry_Owned
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure CorralChoice_StreamProtocol
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure main
[2020-11-25 05:48:35,385 INFO  L130     BoogieDeclarations]: Found specification of procedure FreshRefGenerator__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__success
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure SafeMath_SafeMath__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure add~uint256~uint256_SafeMath__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure sub~uint256~uint256_SafeMath__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure mul~uint256~uint256_SafeMath__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure div~uint256~uint256_SafeMath__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure ERC20Interface_ERC20Interface_NoBaseCtor__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure ERC20Interface_ERC20Interface__success
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure ERC20Interface_ERC20Interface__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure ApproveAndCallFallBack_ApproveAndCallFallBack_NoBaseCtor__fail
[2020-11-25 05:48:35,386 INFO  L130     BoogieDeclarations]: Found specification of procedure ApproveAndCallFallBack_ApproveAndCallFallBack__success
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure ApproveAndCallFallBack_ApproveAndCallFallBack__fail
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure Owned_Owned_NoBaseCtor__fail
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure Owned_Owned__success
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure Owned_Owned__fail
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure owner_Owned__success
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure owner_Owned__fail
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure StreamProtocol_StreamProtocol_NoBaseCtor__fail
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure StreamProtocol_StreamProtocol__success
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure StreamProtocol_StreamProtocol__fail
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure totalSupply_StreamProtocol__success
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure totalSupply_StreamProtocol__fail
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure stopTrade_StreamProtocol__success
[2020-11-25 05:48:35,387 INFO  L130     BoogieDeclarations]: Found specification of procedure stopTrade_StreamProtocol__fail
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure startTrade_StreamProtocol__success
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure startTrade_StreamProtocol__fail
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure balanceOf~address_StreamProtocol__success
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure balanceOf~address_StreamProtocol__fail
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure transfer~address~uint256_StreamProtocol__success
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure transfer~address~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure approve~address~uint256_StreamProtocol__success
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure approve~address~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure transferFrom~address~address~uint256_StreamProtocol__success
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure transferFrom~address~address~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure allowance~address~address_StreamProtocol__success
[2020-11-25 05:48:35,388 INFO  L130     BoogieDeclarations]: Found specification of procedure allowance~address~address_StreamProtocol__fail
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure approveAndCall~address~uint256~bytes_StreamProtocol__success
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure approveAndCall~address~uint256~bytes_StreamProtocol__fail
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackMethod_StreamProtocol__fail
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure transferAnyERC20Token~address~uint256_StreamProtocol__success
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure transferAnyERC20Token~address~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure burn~uint256_StreamProtocol__success
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure burn~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure symbol_StreamProtocol__success
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure symbol_StreamProtocol__fail
[2020-11-25 05:48:35,389 INFO  L130     BoogieDeclarations]: Found specification of procedure name_StreamProtocol__success
[2020-11-25 05:48:35,390 INFO  L130     BoogieDeclarations]: Found specification of procedure name_StreamProtocol__fail
[2020-11-25 05:48:35,390 INFO  L130     BoogieDeclarations]: Found specification of procedure decimals_StreamProtocol__success
[2020-11-25 05:48:35,390 INFO  L130     BoogieDeclarations]: Found specification of procedure decimals_StreamProtocol__fail
[2020-11-25 05:48:35,390 INFO  L130     BoogieDeclarations]: Found specification of procedure FallbackDispatch__fail
[2020-11-25 05:48:35,390 INFO  L130     BoogieDeclarations]: Found specification of procedure Fallback_UnknownType__fail
[2020-11-25 05:48:35,390 INFO  L130     BoogieDeclarations]: Found specification of procedure send__fail
[2020-11-25 05:48:35,390 INFO  L130     BoogieDeclarations]: Found specification of procedure onlyOwner_pre__fail
[2020-11-25 05:48:35,390 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__fail
[2020-11-25 05:48:35,390 INFO  L138     BoogieDeclarations]: Found implementation of procedure FreshRefGenerator__success
[2020-11-25 05:48:35,390 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__fail
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath_NoBaseCtor__success
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__fail
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure SafeMath_SafeMath__success
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure add~uint256~uint256_SafeMath__fail
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure add~uint256~uint256_SafeMath__success
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub~uint256~uint256_SafeMath__fail
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure sub~uint256~uint256_SafeMath__success
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure mul~uint256~uint256_SafeMath__fail
[2020-11-25 05:48:35,391 INFO  L138     BoogieDeclarations]: Found implementation of procedure mul~uint256~uint256_SafeMath__success
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure div~uint256~uint256_SafeMath__fail
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure div~uint256~uint256_SafeMath__success
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure ERC20Interface_ERC20Interface_NoBaseCtor__fail
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure ERC20Interface_ERC20Interface_NoBaseCtor__success
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure ERC20Interface_ERC20Interface__fail
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure ERC20Interface_ERC20Interface__success
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure ApproveAndCallFallBack_ApproveAndCallFallBack_NoBaseCtor__fail
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure ApproveAndCallFallBack_ApproveAndCallFallBack_NoBaseCtor__success
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure ApproveAndCallFallBack_ApproveAndCallFallBack__fail
[2020-11-25 05:48:35,392 INFO  L138     BoogieDeclarations]: Found implementation of procedure ApproveAndCallFallBack_ApproveAndCallFallBack__success
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure Owned_Owned_NoBaseCtor__fail
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure Owned_Owned_NoBaseCtor__success
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure Owned_Owned__fail
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure Owned_Owned__success
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure owner_Owned__fail
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure owner_Owned__success
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure StreamProtocol_StreamProtocol_NoBaseCtor__fail
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure StreamProtocol_StreamProtocol_NoBaseCtor__success
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure StreamProtocol_StreamProtocol__fail
[2020-11-25 05:48:35,393 INFO  L138     BoogieDeclarations]: Found implementation of procedure StreamProtocol_StreamProtocol__success
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure totalSupply_StreamProtocol__fail
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure totalSupply_StreamProtocol__success
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure stopTrade_StreamProtocol__fail
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure stopTrade_StreamProtocol__success
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure startTrade_StreamProtocol__fail
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure startTrade_StreamProtocol__success
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure balanceOf~address_StreamProtocol__fail
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure balanceOf~address_StreamProtocol__success
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure transfer~address~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure transfer~address~uint256_StreamProtocol__success
[2020-11-25 05:48:35,394 INFO  L138     BoogieDeclarations]: Found implementation of procedure approve~address~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure approve~address~uint256_StreamProtocol__success
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferFrom~address~address~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferFrom~address~address~uint256_StreamProtocol__success
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure allowance~address~address_StreamProtocol__fail
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure allowance~address~address_StreamProtocol__success
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure approveAndCall~address~uint256~bytes_StreamProtocol__fail
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure approveAndCall~address~uint256~bytes_StreamProtocol__success
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackMethod_StreamProtocol__fail
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackMethod_StreamProtocol__success
[2020-11-25 05:48:35,395 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferAnyERC20Token~address~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure transferAnyERC20Token~address~uint256_StreamProtocol__success
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure burn~uint256_StreamProtocol__fail
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure burn~uint256_StreamProtocol__success
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure symbol_StreamProtocol__fail
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure symbol_StreamProtocol__success
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure name_StreamProtocol__fail
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure name_StreamProtocol__success
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure decimals_StreamProtocol__fail
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure decimals_StreamProtocol__success
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__fail
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure FallbackDispatch__success
[2020-11-25 05:48:35,396 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__fail
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure Fallback_UnknownType__success
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__fail
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure send__success
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyOwner_pre__fail
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure onlyOwner_pre__success
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_SafeMath
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_SafeMath
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_ERC20Interface
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_ERC20Interface
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_ApproveAndCallFallBack
[2020-11-25 05:48:35,397 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_ApproveAndCallFallBack
[2020-11-25 05:48:35,398 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_Owned
[2020-11-25 05:48:35,398 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralEntry_Owned
[2020-11-25 05:48:35,398 INFO  L138     BoogieDeclarations]: Found implementation of procedure CorralChoice_StreamProtocol
[2020-11-25 05:48:35,398 INFO  L138     BoogieDeclarations]: Found implementation of procedure main
[2020-11-25 05:48:35,398 INFO  L130     BoogieDeclarations]: Found specification of procedure ULTIMATE.start
[2020-11-25 05:48:35,398 INFO  L138     BoogieDeclarations]: Found implementation of procedure ULTIMATE.start
[2020-11-25 05:48:35,491 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-11-25 05:48:35,492 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-11-25 05:48:35,492 WARN  L745   $ProcedureCfgBuilder]: Label in the middle of a codeblock.
[2020-11-25 05:48:36,066 INFO  L281             CfgBuilder]: Using the 1 location(s) as analysis (start of procedure ULTIMATE.start)
[2020-11-25 05:48:36,066 INFO  L286             CfgBuilder]: Removed 5 assue(true) statements.
[2020-11-25 05:48:36,070 INFO  L202        PluginConnector]: Adding new model StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 25.11 05:48:36 BoogieIcfgContainer
[2020-11-25 05:48:36,070 INFO  L185        PluginConnector]: Executing the observer RCFGBuilderObserver from plugin RCFGBuilder for "Hardcoded edu.utexas.cs.utopia.specLang AST 25.11 05:48:35" (2/2) ...
[2020-11-25 05:48:36,070 INFO  L85     RCFGBuilderObserver]: No WrapperNode. Let Ultimate process with next node
[2020-11-25 05:48:36,071 INFO  L205        PluginConnector]: Invalid model from RCFGBuilder for observer de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder.RCFGBuilderObserver@58d1e2e and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 25.11 05:48:36, skipping insertion in model container
[2020-11-25 05:48:36,071 INFO  L132        PluginConnector]: ------------------------ END RCFGBuilder----------------------------
[2020-11-25 05:48:36,071 INFO  L113        PluginConnector]: ------------------------UtopiaLTL2Aut----------------------------
[2020-11-25 05:48:36,072 INFO  L271        PluginConnector]: Initializing UtopiaLTL2Aut...
[2020-11-25 05:48:36,074 INFO  L276        PluginConnector]: UtopiaLTL2Aut initialized
[2020-11-25 05:48:36,074 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/3) ...
[2020-11-25 05:48:36,075 INFO  L205        PluginConnector]: Invalid model from UtopiaLTL2Aut for observer edu.utexas.cs.utopia.ltl2aut.UtopiaLTL2AutObserver@1bd6613 and model type Hardcoded edu.utexas.cs.utopia.ltl2aut AST 25.11 05:48:36, skipping insertion in model container
[2020-11-25 05:48:36,075 INFO  L185        PluginConnector]: Executing the observer UtopiaLTL2AutObserver from plugin UtopiaLTL2Aut for "Hardcoded edu.utexas.cs.utopia.specLang AST 25.11 05:48:35" (2/3) ...
No working directory specified, using /mnt/data0/jon/SmartPulseTool/ltl2ba
Starting monitored process 1 with /mnt/data0/jon/SmartPulseTool/ltl2ba -f ! ( ( [] ( a -> ( <>b ) ) ) )  (exit command is null, workingDir is null)
[2020-11-25 05:48:36,119 INFO  L202        PluginConnector]: Adding new model Hardcoded edu.utexas.cs.utopia.ltl2aut AST 25.11 05:48:36 NWAContainer
[2020-11-25 05:48:36,120 INFO  L132        PluginConnector]: ------------------------ END UtopiaLTL2Aut----------------------------
[2020-11-25 05:48:36,120 INFO  L113        PluginConnector]: ------------------------BÃ¼chi Program Product----------------------------
[2020-11-25 05:48:36,120 INFO  L271        PluginConnector]: Initializing BÃ¼chi Program Product...
[2020-11-25 05:48:36,121 INFO  L276        PluginConnector]: BÃ¼chi Program Product initialized
[2020-11-25 05:48:36,122 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin BÃ¼chi Program Product for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 25.11 05:48:36" (3/4) ...
[2020-11-25 05:48:36,122 INFO  L205        PluginConnector]: Invalid model from BÃ¼chi Program Product for observer de.uni_freiburg.informatik.ultimate.buchiprogramproduct.BuchiProductObserver@6a21db13 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 25.11 05:48:36, skipping insertion in model container
[2020-11-25 05:48:36,123 INFO  L185        PluginConnector]: Executing the observer BuchiProductObserver from plugin BÃ¼chi Program Product for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 25.11 05:48:36" (4/4) ...
[2020-11-25 05:48:36,126 INFO  L104   BuchiProductObserver]: Initial property automaton 2 locations, 3 edges
[2020-11-25 05:48:36,129 INFO  L110   BuchiProductObserver]: Initial RCFG 1309 locations, 1635 edges
[2020-11-25 05:48:36,129 INFO  L93    BuchiProductObserver]: Beginning generation of product automaton
[2020-11-25 05:48:36,140 INFO  L136       ProductGenerator]: The program has no step specification, so we assume maximum atomicity
[2020-11-25 05:48:37,460 INFO  L97    BuchiProductObserver]: Finished generation of product automaton successfully
[2020-11-25 05:48:37,464 INFO  L110   BuchiProductObserver]: BuchiProgram size 3092 locations, 5270 edges
[2020-11-25 05:48:37,464 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 25.11 05:48:37 BoogieIcfgContainer
[2020-11-25 05:48:37,464 INFO  L132        PluginConnector]: ------------------------ END BÃ¼chi Program Product----------------------------
[2020-11-25 05:48:37,464 INFO  L113        PluginConnector]: ------------------------BlockEncodingV2----------------------------
[2020-11-25 05:48:37,464 INFO  L271        PluginConnector]: Initializing BlockEncodingV2...
[2020-11-25 05:48:37,465 INFO  L276        PluginConnector]: BlockEncodingV2 initialized
[2020-11-25 05:48:37,466 INFO  L185        PluginConnector]: Executing the observer BlockEncodingObserver from plugin BlockEncodingV2 for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 25.11 05:48:37" (1/1) ...
[2020-11-25 05:48:37,529 INFO  L313           BlockEncoder]: Initial Icfg 3092 locations, 5270 edges
[2020-11-25 05:48:37,529 INFO  L258           BlockEncoder]: Using Remove infeasible edges
[2020-11-25 05:48:37,530 INFO  L270           BlockEncoder]: Using Minimize states even if more edges are added than removed.=true
[2020-11-25 05:48:37,530 INFO  L296           BlockEncoder]: Using Remove sink states
[2020-11-25 05:48:37,531 INFO  L171           BlockEncoder]: Using Apply optimizations until nothing changes=true
[2020-11-25 05:48:37,543 INFO  L70    emoveInfeasibleEdges]: Removed 60 edges and 13 locations because of local infeasibility
[2020-11-25 05:48:37,552 INFO  L70        RemoveSinkStates]: Removed 8 edges and 5 locations by removing sink states
[2020-11-25 05:48:37,562 INFO  L70    emoveInfeasibleEdges]: Removed 0 edges and 0 locations because of local infeasibility
[2020-11-25 05:48:37,565 INFO  L70        RemoveSinkStates]: Removed 0 edges and 0 locations by removing sink states
[2020-11-25 05:48:37,567 INFO  L237           BlockEncoder]: Using Create parallel compositions if possible
[2020-11-25 05:48:37,568 INFO  L66        ParallelComposer]: Creating parallel compositions
[2020-11-25 05:48:37,571 INFO  L313           BlockEncoder]: Encoded RCFG 3052 locations, 5170 edges
[2020-11-25 05:48:37,571 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 25.11 05:48:37 BasicIcfg
[2020-11-25 05:48:37,571 INFO  L132        PluginConnector]: ------------------------ END BlockEncodingV2----------------------------
[2020-11-25 05:48:37,571 INFO  L113        PluginConnector]: ------------------------BuchiAutomizer----------------------------
[2020-11-25 05:48:37,571 INFO  L271        PluginConnector]: Initializing BuchiAutomizer...
[2020-11-25 05:48:37,573 INFO  L276        PluginConnector]: BuchiAutomizer initialized
[2020-11-25 05:48:37,573 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-11-25 05:48:37,573 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.boogie.parser AST 25.11 05:48:35" (1/6) ...
[2020-11-25 05:48:37,575 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@253606b6 and model type StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 25.11 05:48:37, skipping insertion in model container
[2020-11-25 05:48:37,576 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-11-25 05:48:37,576 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.specLang AST 25.11 05:48:35" (2/6) ...
[2020-11-25 05:48:37,576 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@253606b6 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 25.11 05:48:37, skipping insertion in model container
[2020-11-25 05:48:37,576 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-11-25 05:48:37,576 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.rcfgbuilder CFG 25.11 05:48:36" (3/6) ...
[2020-11-25 05:48:37,576 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@253606b6 and model type StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 25.11 05:48:37, skipping insertion in model container
[2020-11-25 05:48:37,576 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-11-25 05:48:37,576 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "Hardcoded edu.utexas.cs.utopia.ltl2aut AST 25.11 05:48:36" (4/6) ...
[2020-11-25 05:48:37,576 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@253606b6 and model type Hardcoded de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer AST 25.11 05:48:37, skipping insertion in model container
[2020-11-25 05:48:37,576 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-11-25 05:48:37,576 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.buchiprogramproduct OTHER 25.11 05:48:37" (5/6) ...
[2020-11-25 05:48:37,577 INFO  L205        PluginConnector]: Invalid model from BuchiAutomizer for observer de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer.BuchiAutomizerObserver@253606b6 and model type LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer OTHER 25.11 05:48:37, skipping insertion in model container
[2020-11-25 05:48:37,577 INFO  L102         BuchiAutomizer]: Safety of program was proven or not checked, starting termination analysis
[2020-11-25 05:48:37,577 INFO  L185        PluginConnector]: Executing the observer BuchiAutomizerObserver from plugin BuchiAutomizer for "LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.blockencoding CFG 25.11 05:48:37" (6/6) ...
[2020-11-25 05:48:37,579 INFO  L404   chiAutomizerObserver]: Analyzing ICFG StreamProtocol_0x9b5C2BE869a19e84BDBcb1386dAD83a2ec8DAe82_totalsupply.bpl_BEv2
[2020-11-25 05:48:37,612 INFO  L133   ementStrategyFactory]: Using default assertion order modulation
[2020-11-25 05:48:37,612 INFO  L377         BuchiCegarLoop]: Interprodecural is true
[2020-11-25 05:48:37,612 INFO  L378         BuchiCegarLoop]: Hoare is false
[2020-11-25 05:48:37,612 INFO  L379         BuchiCegarLoop]: Compute interpolants for Craig_TreeInterpolation
[2020-11-25 05:48:37,612 INFO  L380         BuchiCegarLoop]: Backedges is STRAIGHT_LINE
[2020-11-25 05:48:37,612 INFO  L381         BuchiCegarLoop]: Determinization is PREDICATE_ABSTRACTION
[2020-11-25 05:48:37,612 INFO  L382         BuchiCegarLoop]: Difference is false
[2020-11-25 05:48:37,612 INFO  L383         BuchiCegarLoop]: Minimize is MINIMIZE_SEVPA
[2020-11-25 05:48:37,612 INFO  L386         BuchiCegarLoop]: ======== Iteration 0==of CEGAR loop == BuchiCegarLoop========
[2020-11-25 05:48:37,638 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 3052 states.
[2020-11-25 05:48:37,684 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-11-25 05:48:37,684 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:37,684 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:37,693 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:37,694 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:37,694 INFO  L445         BuchiCegarLoop]: ======== Iteration 1============
[2020-11-25 05:48:37,694 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 3052 states.
[2020-11-25 05:48:37,710 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-11-25 05:48:37,710 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:37,710 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:37,712 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:37,712 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND TRUE   revert
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:37,733 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:37,733 INFO  L82        PathProgramCache]: Analyzing trace with hash 315834335, now seen corresponding path program 1 times
[2020-11-25 05:48:37,741 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:37,761 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:37,798 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-11-25 05:48:37,800 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-11-25 05:48:37,800 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [3] imperfect sequences [] total 3
[2020-11-25 05:48:37,907 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:37,922 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 3 interpolants.
[2020-11-25 05:48:37,923 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=3, Invalid=3, Unknown=0, NotChecked=0, Total=6
[2020-11-25 05:48:37,924 INFO  L87              Difference]: Start difference. First operand 3052 states. Second operand 3 states.
[2020-11-25 05:48:38,110 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:38,110 INFO  L93              Difference]: Finished difference Result 2154 states and 2409 transitions.
[2020-11-25 05:48:38,111 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 3 states. 
[2020-11-25 05:48:38,112 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 2154 states and 2409 transitions.
[2020-11-25 05:48:38,128 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-11-25 05:48:38,147 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 2154 states to 2154 states and 2409 transitions.
[2020-11-25 05:48:38,148 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 4
[2020-11-25 05:48:38,150 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 603
[2020-11-25 05:48:38,150 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 2154 states and 2409 transitions.
[2020-11-25 05:48:38,157 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:38,158 INFO  L728         BuchiCegarLoop]: Abstraction has 2154 states and 2409 transitions.
[2020-11-25 05:48:38,175 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 2154 states and 2409 transitions.
[2020-11-25 05:48:38,216 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 2154 to 2154.
[2020-11-25 05:48:38,217 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 2154 states.
[2020-11-25 05:48:38,223 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 2154 states to 2154 states and 2409 transitions.
[2020-11-25 05:48:38,224 INFO  L751         BuchiCegarLoop]: Abstraction has 2154 states and 2409 transitions.
[2020-11-25 05:48:38,224 INFO  L631         BuchiCegarLoop]: Abstraction has 2154 states and 2409 transitions.
[2020-11-25 05:48:38,224 INFO  L445         BuchiCegarLoop]: ======== Iteration 2============
[2020-11-25 05:48:38,224 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 2154 states and 2409 transitions.
[2020-11-25 05:48:38,232 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-11-25 05:48:38,232 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:38,232 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:38,234 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:38,234 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND TRUE   revert
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND TRUE   revert
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND TRUE   revert
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:38,239 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:38,239 INFO  L82        PathProgramCache]: Analyzing trace with hash 612853604, now seen corresponding path program 1 times
[2020-11-25 05:48:38,240 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:38,251 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:38,274 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-11-25 05:48:38,274 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-11-25 05:48:38,274 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [4] imperfect sequences [] total 4
[2020-11-25 05:48:38,276 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:38,276 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 4 interpolants.
[2020-11-25 05:48:38,276 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=5, Invalid=7, Unknown=0, NotChecked=0, Total=12
[2020-11-25 05:48:38,277 INFO  L87              Difference]: Start difference. First operand 2154 states and 2409 transitions. cyclomatic complexity: 257 Second operand 4 states.
[2020-11-25 05:48:38,656 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:38,656 INFO  L93              Difference]: Finished difference Result 3200 states and 3665 transitions.
[2020-11-25 05:48:38,656 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 4 states. 
[2020-11-25 05:48:38,656 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 3200 states and 3665 transitions.
[2020-11-25 05:48:38,668 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 6
[2020-11-25 05:48:38,680 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 3200 states to 3032 states and 3471 transitions.
[2020-11-25 05:48:38,680 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 822
[2020-11-25 05:48:38,681 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 834
[2020-11-25 05:48:38,681 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 3032 states and 3471 transitions.
[2020-11-25 05:48:38,686 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:38,686 INFO  L728         BuchiCegarLoop]: Abstraction has 3032 states and 3471 transitions.
[2020-11-25 05:48:38,689 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 3032 states and 3471 transitions.
[2020-11-25 05:48:38,711 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 3032 to 2190.
[2020-11-25 05:48:38,711 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 2190 states.
[2020-11-25 05:48:38,714 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 2190 states to 2190 states and 2377 transitions.
[2020-11-25 05:48:38,714 INFO  L751         BuchiCegarLoop]: Abstraction has 2190 states and 2377 transitions.
[2020-11-25 05:48:38,714 INFO  L631         BuchiCegarLoop]: Abstraction has 2190 states and 2377 transitions.
[2020-11-25 05:48:38,714 INFO  L445         BuchiCegarLoop]: ======== Iteration 3============
[2020-11-25 05:48:38,714 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 2190 states and 2377 transitions.
[2020-11-25 05:48:38,718 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-11-25 05:48:38,718 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:38,718 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:38,720 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:38,720 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:38,723 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:38,723 INFO  L82        PathProgramCache]: Analyzing trace with hash 403291258, now seen corresponding path program 1 times
[2020-11-25 05:48:38,723 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:38,743 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:38,953 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-11-25 05:48:38,953 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-11-25 05:48:38,954 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [20] imperfect sequences [] total 20
[2020-11-25 05:48:38,954 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:38,954 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 21 interpolants.
[2020-11-25 05:48:38,954 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=42, Invalid=378, Unknown=0, NotChecked=0, Total=420
[2020-11-25 05:48:38,954 INFO  L87              Difference]: Start difference. First operand 2190 states and 2377 transitions. cyclomatic complexity: 189 Second operand 21 states.
[2020-11-25 05:48:41,543 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:41,543 INFO  L93              Difference]: Finished difference Result 2331 states and 2542 transitions.
[2020-11-25 05:48:41,543 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 21 states. 
[2020-11-25 05:48:41,544 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 2331 states and 2542 transitions.
[2020-11-25 05:48:41,550 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-11-25 05:48:41,557 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 2331 states to 2331 states and 2542 transitions.
[2020-11-25 05:48:41,557 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 664
[2020-11-25 05:48:41,558 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 664
[2020-11-25 05:48:41,558 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 2331 states and 2542 transitions.
[2020-11-25 05:48:41,560 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:41,560 INFO  L728         BuchiCegarLoop]: Abstraction has 2331 states and 2542 transitions.
[2020-11-25 05:48:41,562 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 2331 states and 2542 transitions.
[2020-11-25 05:48:41,581 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 2331 to 2307.
[2020-11-25 05:48:41,581 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 2307 states.
[2020-11-25 05:48:41,583 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 2307 states to 2307 states and 2507 transitions.
[2020-11-25 05:48:41,583 INFO  L751         BuchiCegarLoop]: Abstraction has 2307 states and 2507 transitions.
[2020-11-25 05:48:41,584 INFO  L631         BuchiCegarLoop]: Abstraction has 2307 states and 2507 transitions.
[2020-11-25 05:48:41,584 INFO  L445         BuchiCegarLoop]: ======== Iteration 4============
[2020-11-25 05:48:41,584 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 2307 states and 2507 transitions.
[2020-11-25 05:48:41,587 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-11-25 05:48:41,587 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:41,587 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:41,589 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:41,589 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL       call CorralChoice_StreamProtocol(this);
[L3458]             havoc msgsender_MSG;
[L3459]             havoc msgvalue_MSG;
[L3460]             havoc choice;
[L3461]             havoc __ret_0_totalSupply;
[L3462]             havoc tokenOwner_s328;
[L3463]             havoc balance_s328;
[L3464]             havoc tokenOwner_s532;
[L3465]             havoc spender_s532;
[L3466]             havoc remaining_s532;
[L3467]             havoc to_s385;
[L3468]             havoc tokens_s385;
[L3469]             havoc success_s385;
[L3470]             havoc spender_s419;
[L3471]             havoc tokens_s419;
[L3472]             havoc success_s419;
[L3473]             havoc from_s510;
[L3474]             havoc to_s510;
[L3475]             havoc tokens_s510;
[L3476]             havoc success_s510;
[L3477]             havoc __ret_0_owner;
[L3478]             havoc __ret_0_symbol;
[L3479]             havoc __ret_0_name;
[L3480]             havoc __ret_0_decimals;
[L3481]             havoc spender_s582;
[L3482]             havoc tokens_s582;
[L3483]             havoc data_s582;
[L3484]             havoc success_s582;
[L3485]             havoc tokenAddress_s609;
[L3486]             havoc tokens_s609;
[L3487]             havoc success_s609;
[L3488]             havoc _value_s658;
[L3489]             havoc tmpNow;
[L3490]             havoc gas;
[L3491]             assume gas > 4000000 && gas <= 8000000;
[L3492]             tmpNow := now;
[L3493]             havoc now;
[L3494]             assume now > tmpNow;
[L3495]             assume msgsender_MSG != null;
[L3496]             assume DType[msgsender_MSG] != SafeMath;
[L3497]             assume DType[msgsender_MSG] != ERC20Interface;
[L3498]             assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]             assume DType[msgsender_MSG] != Owned;
[L3500]             assume DType[msgsender_MSG] != StreamProtocol;
[L3501]             Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE  choice == 15
[L3503]             gas := gas - 21000;
[L3504]  COND TRUE  gas >= 0
[L3505]             assume msgvalue_MSG == 0;
[L3506]  CALL       call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                revert_hold := revert;
[L2]                revert := false;
[L2]                assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                call_totalSupply_StreamProtocol0 := true;
[L2]                call_totalSupply_StreamProtocol0 := false;
[L2]                revert := revert_hold;
[L448]              havoc __exception;
[L449]              revert := false;
[L450]   COND TRUE  __exception
[L451]              __tmp__Balance := Balance;
[L452]              __tmp__DType := DType;
[L453]              __tmp__Alloc := Alloc;
[L454]              __tmp__balance_ADDR := balance_ADDR;
[L455]              __tmp__M_Ref_int := M_Ref_int;
[L456]              __tmp__sum_balances0 := sum_balances0;
[L457]              __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]              __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]              __tmp__sum_allowed1 := sum_allowed1;
[L460]              __tmp__Length := Length;
[L461]              __tmp__now := now;
[L462]              __tmp__owner_Owned := owner_Owned;
[L463]              __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]              __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]              __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]              __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]              __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]              __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]              __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL       call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]             __var_3 := null;
[L1941]  CALL       call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE  !(b_s45 <= a_s45)
[L1684]             revert := true;
[L1941]  RET        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE  revert
[L470]   RET        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]              assume revert || gas < 0;
[L3506]  RET        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET        call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:41,592 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:41,592 INFO  L82        PathProgramCache]: Analyzing trace with hash 486232039, now seen corresponding path program 1 times
[2020-11-25 05:48:41,593 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:41,600 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:41,672 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-11-25 05:48:41,672 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-11-25 05:48:41,672 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [20] imperfect sequences [] total 20
[2020-11-25 05:48:41,672 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:41,672 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 21 interpolants.
[2020-11-25 05:48:41,673 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=43, Invalid=377, Unknown=0, NotChecked=0, Total=420
[2020-11-25 05:48:41,673 INFO  L87              Difference]: Start difference. First operand 2307 states and 2507 transitions. cyclomatic complexity: 204 Second operand 21 states.
[2020-11-25 05:48:42,939 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:42,940 INFO  L93              Difference]: Finished difference Result 2343 states and 2559 transitions.
[2020-11-25 05:48:42,940 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 21 states. 
[2020-11-25 05:48:42,940 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 2343 states and 2559 transitions.
[2020-11-25 05:48:42,946 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 6
[2020-11-25 05:48:42,951 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 2343 states to 2343 states and 2559 transitions.
[2020-11-25 05:48:42,951 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 673
[2020-11-25 05:48:42,952 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 673
[2020-11-25 05:48:42,952 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 2343 states and 2559 transitions.
[2020-11-25 05:48:42,954 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:42,954 INFO  L728         BuchiCegarLoop]: Abstraction has 2343 states and 2559 transitions.
[2020-11-25 05:48:42,956 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 2343 states and 2559 transitions.
[2020-11-25 05:48:42,970 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 2343 to 2322.
[2020-11-25 05:48:42,970 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 2322 states.
[2020-11-25 05:48:42,973 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 2322 states to 2322 states and 2525 transitions.
[2020-11-25 05:48:42,973 INFO  L751         BuchiCegarLoop]: Abstraction has 2322 states and 2525 transitions.
[2020-11-25 05:48:42,973 INFO  L631         BuchiCegarLoop]: Abstraction has 2322 states and 2525 transitions.
[2020-11-25 05:48:42,973 INFO  L445         BuchiCegarLoop]: ======== Iteration 5============
[2020-11-25 05:48:42,973 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 2322 states and 2525 transitions.
[2020-11-25 05:48:42,976 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-11-25 05:48:42,976 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:42,976 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:42,977 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:42,977 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND FALSE  !(!(b_s45 <= a_s45))
[L1687]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND FALSE  !(revert)
[L1945]              __ret_0_ := __var_2;
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND FALSE  !(!(b_s45 <= a_s45))
[L1687]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND FALSE  !(revert)
[L1945]              __ret_0_ := __var_2;
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:42,979 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:42,979 INFO  L82        PathProgramCache]: Analyzing trace with hash -906358972, now seen corresponding path program 1 times
[2020-11-25 05:48:42,980 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:42,986 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:43,004 INFO  L134       CoverageAnalysis]: Checked inductivity of 0 backedges. 0 proven. 0 refuted. 0 times theorem prover too weak. 0 trivial. 0 not checked.
[2020-11-25 05:48:43,004 INFO  L312   seRefinementStrategy]: Constructing automaton from 1 perfect and 0 imperfect interpolant sequences.
[2020-11-25 05:48:43,004 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [5] imperfect sequences [] total 5
[2020-11-25 05:48:43,004 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:43,004 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 5 interpolants.
[2020-11-25 05:48:43,004 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=7, Invalid=13, Unknown=0, NotChecked=0, Total=20
[2020-11-25 05:48:43,004 INFO  L87              Difference]: Start difference. First operand 2322 states and 2525 transitions. cyclomatic complexity: 207 Second operand 5 states.
[2020-11-25 05:48:43,289 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:43,290 INFO  L93              Difference]: Finished difference Result 2933 states and 3256 transitions.
[2020-11-25 05:48:43,290 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 7 states. 
[2020-11-25 05:48:43,290 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 2933 states and 3256 transitions.
[2020-11-25 05:48:43,296 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 8
[2020-11-25 05:48:43,303 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 2933 states to 2424 states and 2745 transitions.
[2020-11-25 05:48:43,303 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 580
[2020-11-25 05:48:43,303 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 580
[2020-11-25 05:48:43,304 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 2424 states and 2745 transitions.
[2020-11-25 05:48:43,306 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:43,306 INFO  L728         BuchiCegarLoop]: Abstraction has 2424 states and 2745 transitions.
[2020-11-25 05:48:43,307 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 2424 states and 2745 transitions.
[2020-11-25 05:48:43,319 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 2424 to 1841.
[2020-11-25 05:48:43,319 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 1841 states.
[2020-11-25 05:48:43,321 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 1841 states to 1841 states and 2003 transitions.
[2020-11-25 05:48:43,321 INFO  L751         BuchiCegarLoop]: Abstraction has 1841 states and 2003 transitions.
[2020-11-25 05:48:43,321 INFO  L631         BuchiCegarLoop]: Abstraction has 1841 states and 2003 transitions.
[2020-11-25 05:48:43,321 INFO  L445         BuchiCegarLoop]: ======== Iteration 6============
[2020-11-25 05:48:43,321 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 1841 states and 2003 transitions.
[2020-11-25 05:48:43,323 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 2
[2020-11-25 05:48:43,323 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:43,323 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:43,324 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:43,324 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:43,328 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:43,328 INFO  L82        PathProgramCache]: Analyzing trace with hash -803111159, now seen corresponding path program 1 times
[2020-11-25 05:48:43,328 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:43,343 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:43,559 INFO  L134       CoverageAnalysis]: Checked inductivity of 47 backedges. 0 proven. 7 refuted. 0 times theorem prover too weak. 40 trivial. 0 not checked.
[2020-11-25 05:48:43,559 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:43,559 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [27] total 27
[2020-11-25 05:48:43,559 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:43,560 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 28 interpolants.
[2020-11-25 05:48:43,560 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=69, Invalid=687, Unknown=0, NotChecked=0, Total=756
[2020-11-25 05:48:43,560 INFO  L87              Difference]: Start difference. First operand 1841 states and 2003 transitions. cyclomatic complexity: 165 Second operand 28 states.
[2020-11-25 05:48:45,566 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:45,566 INFO  L93              Difference]: Finished difference Result 1912 states and 2089 transitions.
[2020-11-25 05:48:45,567 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 27 states. 
[2020-11-25 05:48:45,567 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 1912 states and 2089 transitions.
[2020-11-25 05:48:45,570 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-11-25 05:48:45,573 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 1912 states to 1912 states and 2089 transitions.
[2020-11-25 05:48:45,574 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 497
[2020-11-25 05:48:45,574 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 497
[2020-11-25 05:48:45,574 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 1912 states and 2089 transitions.
[2020-11-25 05:48:45,576 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:45,576 INFO  L728         BuchiCegarLoop]: Abstraction has 1912 states and 2089 transitions.
[2020-11-25 05:48:45,577 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 1912 states and 2089 transitions.
[2020-11-25 05:48:45,586 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 1912 to 1895.
[2020-11-25 05:48:45,586 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 1895 states.
[2020-11-25 05:48:45,588 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 1895 states to 1895 states and 2069 transitions.
[2020-11-25 05:48:45,588 INFO  L751         BuchiCegarLoop]: Abstraction has 1895 states and 2069 transitions.
[2020-11-25 05:48:45,588 INFO  L631         BuchiCegarLoop]: Abstraction has 1895 states and 2069 transitions.
[2020-11-25 05:48:45,588 INFO  L445         BuchiCegarLoop]: ======== Iteration 7============
[2020-11-25 05:48:45,588 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 1895 states and 2069 transitions.
[2020-11-25 05:48:45,590 INFO  L131   ngComponentsAnalysis]: Automaton has 2 accepting balls. 4
[2020-11-25 05:48:45,590 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:45,590 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:45,591 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:45,591 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:45,593 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:45,593 INFO  L82        PathProgramCache]: Analyzing trace with hash -655889354, now seen corresponding path program 1 times
[2020-11-25 05:48:45,594 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:45,603 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:45,712 INFO  L134       CoverageAnalysis]: Checked inductivity of 47 backedges. 0 proven. 7 refuted. 0 times theorem prover too weak. 40 trivial. 0 not checked.
[2020-11-25 05:48:45,713 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:45,713 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [27] total 27
[2020-11-25 05:48:45,713 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:45,713 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 28 interpolants.
[2020-11-25 05:48:45,713 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=69, Invalid=687, Unknown=0, NotChecked=0, Total=756
[2020-11-25 05:48:45,713 INFO  L87              Difference]: Start difference. First operand 1895 states and 2069 transitions. cyclomatic complexity: 179 Second operand 28 states.
[2020-11-25 05:48:48,483 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:48,483 INFO  L93              Difference]: Finished difference Result 4542 states and 5061 transitions.
[2020-11-25 05:48:48,483 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 39 states. 
[2020-11-25 05:48:48,483 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 4542 states and 5061 transitions.
[2020-11-25 05:48:48,491 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 6
[2020-11-25 05:48:48,501 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 4542 states to 4542 states and 5061 transitions.
[2020-11-25 05:48:48,501 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1162
[2020-11-25 05:48:48,502 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1659
[2020-11-25 05:48:48,502 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 4542 states and 5061 transitions.
[2020-11-25 05:48:48,506 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:48,506 INFO  L728         BuchiCegarLoop]: Abstraction has 4542 states and 5061 transitions.
[2020-11-25 05:48:48,508 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 4542 states and 5061 transitions.
[2020-11-25 05:48:48,527 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 4542 to 3723.
[2020-11-25 05:48:48,528 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 3723 states.
[2020-11-25 05:48:48,531 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 3723 states to 3723 states and 4218 transitions.
[2020-11-25 05:48:48,531 INFO  L751         BuchiCegarLoop]: Abstraction has 3723 states and 4218 transitions.
[2020-11-25 05:48:48,531 INFO  L631         BuchiCegarLoop]: Abstraction has 3723 states and 4218 transitions.
[2020-11-25 05:48:48,531 INFO  L445         BuchiCegarLoop]: ======== Iteration 8============
[2020-11-25 05:48:48,532 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 3723 states and 4218 transitions.
[2020-11-25 05:48:48,537 INFO  L131   ngComponentsAnalysis]: Automaton has 1 accepting balls. 6
[2020-11-25 05:48:48,537 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:48,537 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:48,538 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:48,538 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL       call CorralChoice_StreamProtocol(this);
[L3458]             havoc msgsender_MSG;
[L3459]             havoc msgvalue_MSG;
[L3460]             havoc choice;
[L3461]             havoc __ret_0_totalSupply;
[L3462]             havoc tokenOwner_s328;
[L3463]             havoc balance_s328;
[L3464]             havoc tokenOwner_s532;
[L3465]             havoc spender_s532;
[L3466]             havoc remaining_s532;
[L3467]             havoc to_s385;
[L3468]             havoc tokens_s385;
[L3469]             havoc success_s385;
[L3470]             havoc spender_s419;
[L3471]             havoc tokens_s419;
[L3472]             havoc success_s419;
[L3473]             havoc from_s510;
[L3474]             havoc to_s510;
[L3475]             havoc tokens_s510;
[L3476]             havoc success_s510;
[L3477]             havoc __ret_0_owner;
[L3478]             havoc __ret_0_symbol;
[L3479]             havoc __ret_0_name;
[L3480]             havoc __ret_0_decimals;
[L3481]             havoc spender_s582;
[L3482]             havoc tokens_s582;
[L3483]             havoc data_s582;
[L3484]             havoc success_s582;
[L3485]             havoc tokenAddress_s609;
[L3486]             havoc tokens_s609;
[L3487]             havoc success_s609;
[L3488]             havoc _value_s658;
[L3489]             havoc tmpNow;
[L3490]             havoc gas;
[L3491]             assume gas > 4000000 && gas <= 8000000;
[L3492]             tmpNow := now;
[L3493]             havoc now;
[L3494]             assume now > tmpNow;
[L3495]             assume msgsender_MSG != null;
[L3496]             assume DType[msgsender_MSG] != SafeMath;
[L3497]             assume DType[msgsender_MSG] != ERC20Interface;
[L3498]             assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]             assume DType[msgsender_MSG] != Owned;
[L3500]             assume DType[msgsender_MSG] != StreamProtocol;
[L3501]             Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE  choice == 15
[L3503]             gas := gas - 21000;
[L3504]  COND TRUE  gas >= 0
[L3505]             assume msgvalue_MSG == 0;
[L3506]  CALL       call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                revert_hold := revert;
[L2]                revert := false;
[L2]                assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                call_totalSupply_StreamProtocol0 := true;
[L2]                call_totalSupply_StreamProtocol0 := false;
[L2]                revert := revert_hold;
[L448]              havoc __exception;
[L449]              revert := false;
[L450]   COND TRUE  __exception
[L451]              __tmp__Balance := Balance;
[L452]              __tmp__DType := DType;
[L453]              __tmp__Alloc := Alloc;
[L454]              __tmp__balance_ADDR := balance_ADDR;
[L455]              __tmp__M_Ref_int := M_Ref_int;
[L456]              __tmp__sum_balances0 := sum_balances0;
[L457]              __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]              __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]              __tmp__sum_allowed1 := sum_allowed1;
[L460]              __tmp__Length := Length;
[L461]              __tmp__now := now;
[L462]              __tmp__owner_Owned := owner_Owned;
[L463]              __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]              __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]              __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]              __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]              __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]              __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]              __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL       call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]             __var_3 := null;
[L1941]  CALL       call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE  !(b_s45 <= a_s45)
[L1684]             revert := true;
[L1941]  RET        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE  revert
[L470]   RET        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]              assume revert || gas < 0;
[L3506]  RET        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET        call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:48,541 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:48,541 INFO  L82        PathProgramCache]: Analyzing trace with hash 665181116, now seen corresponding path program 1 times
[2020-11-25 05:48:48,542 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:48,551 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:48,686 INFO  L134       CoverageAnalysis]: Checked inductivity of 47 backedges. 0 proven. 1 refuted. 0 times theorem prover too weak. 46 trivial. 0 not checked.
[2020-11-25 05:48:48,686 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:48,686 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [28] total 28
[2020-11-25 05:48:48,686 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:48,686 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 29 interpolants.
[2020-11-25 05:48:48,687 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=68, Invalid=744, Unknown=0, NotChecked=0, Total=812
[2020-11-25 05:48:48,687 INFO  L87              Difference]: Start difference. First operand 3723 states and 4218 transitions. cyclomatic complexity: 499 Second operand 29 states.
[2020-11-25 05:48:52,278 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:52,278 INFO  L93              Difference]: Finished difference Result 4499 states and 5063 transitions.
[2020-11-25 05:48:52,279 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 40 states. 
[2020-11-25 05:48:52,279 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 4499 states and 5063 transitions.
[2020-11-25 05:48:52,288 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-11-25 05:48:52,298 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 4499 states to 4499 states and 5063 transitions.
[2020-11-25 05:48:52,298 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1667
[2020-11-25 05:48:52,299 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1667
[2020-11-25 05:48:52,299 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 4499 states and 5063 transitions.
[2020-11-25 05:48:52,301 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:52,301 INFO  L728         BuchiCegarLoop]: Abstraction has 4499 states and 5063 transitions.
[2020-11-25 05:48:52,303 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 4499 states and 5063 transitions.
[2020-11-25 05:48:52,324 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 4499 to 3753.
[2020-11-25 05:48:52,324 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 3753 states.
[2020-11-25 05:48:52,328 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 3753 states to 3753 states and 4316 transitions.
[2020-11-25 05:48:52,328 INFO  L751         BuchiCegarLoop]: Abstraction has 3753 states and 4316 transitions.
[2020-11-25 05:48:52,328 INFO  L631         BuchiCegarLoop]: Abstraction has 3753 states and 4316 transitions.
[2020-11-25 05:48:52,328 INFO  L445         BuchiCegarLoop]: ======== Iteration 9============
[2020-11-25 05:48:52,328 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 3753 states and 4316 transitions.
[2020-11-25 05:48:52,332 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 12
[2020-11-25 05:48:52,332 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:52,332 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:52,333 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:52,333 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:52,336 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:52,336 INFO  L82        PathProgramCache]: Analyzing trace with hash -851763812, now seen corresponding path program 1 times
[2020-11-25 05:48:52,336 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:52,345 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:52,580 INFO  L134       CoverageAnalysis]: Checked inductivity of 51 backedges. 39 proven. 7 refuted. 0 times theorem prover too weak. 5 trivial. 0 not checked.
[2020-11-25 05:48:52,580 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:52,580 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [27] total 27
[2020-11-25 05:48:52,581 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:52,581 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 28 interpolants.
[2020-11-25 05:48:52,581 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=74, Invalid=682, Unknown=0, NotChecked=0, Total=756
[2020-11-25 05:48:52,581 INFO  L87              Difference]: Start difference. First operand 3753 states and 4316 transitions. cyclomatic complexity: 573 Second operand 28 states.
[2020-11-25 05:48:53,912 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:53,912 INFO  L93              Difference]: Finished difference Result 3807 states and 4431 transitions.
[2020-11-25 05:48:53,913 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 27 states. 
[2020-11-25 05:48:53,913 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 3807 states and 4431 transitions.
[2020-11-25 05:48:53,922 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 18
[2020-11-25 05:48:53,933 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 3807 states to 3807 states and 4431 transitions.
[2020-11-25 05:48:53,933 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 1294
[2020-11-25 05:48:53,933 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 1294
[2020-11-25 05:48:53,933 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 3807 states and 4431 transitions.
[2020-11-25 05:48:53,936 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:53,936 INFO  L728         BuchiCegarLoop]: Abstraction has 3807 states and 4431 transitions.
[2020-11-25 05:48:53,940 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 3807 states and 4431 transitions.
[2020-11-25 05:48:53,960 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 3807 to 3796.
[2020-11-25 05:48:53,960 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 3796 states.
[2020-11-25 05:48:53,964 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 3796 states to 3796 states and 4418 transitions.
[2020-11-25 05:48:53,964 INFO  L751         BuchiCegarLoop]: Abstraction has 3796 states and 4418 transitions.
[2020-11-25 05:48:53,964 INFO  L631         BuchiCegarLoop]: Abstraction has 3796 states and 4418 transitions.
[2020-11-25 05:48:53,965 INFO  L445         BuchiCegarLoop]: ======== Iteration 10============
[2020-11-25 05:48:53,965 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 3796 states and 4418 transitions.
[2020-11-25 05:48:53,969 INFO  L131   ngComponentsAnalysis]: Automaton has 4 accepting balls. 18
[2020-11-25 05:48:53,969 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:53,969 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:53,970 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:53,970 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND TRUE   choice == 13
[L3515]              gas := gas - 21000;
[L3516]  COND TRUE   gas >= 0
[L3517]              assume msgvalue_MSG == 0;
[L3518]  CALL        call remaining_s532 := allowance~address~address_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenOwner_s532, spender_s532);
[L836]               havoc __exception;
[L837]               revert := false;
[L838]   COND TRUE   __exception
[L839]               __tmp__Balance := Balance;
[L840]               __tmp__DType := DType;
[L841]               __tmp__Alloc := Alloc;
[L842]               __tmp__balance_ADDR := balance_ADDR;
[L843]               __tmp__M_Ref_int := M_Ref_int;
[L844]               __tmp__sum_balances0 := sum_balances0;
[L845]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L846]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L847]               __tmp__sum_allowed1 := sum_allowed1;
[L848]               __tmp__Length := Length;
[L849]               __tmp__now := now;
[L850]               __tmp__owner_Owned := owner_Owned;
[L851]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L852]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L853]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L854]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L855]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L856]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L857]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L858]   CALL        call remaining_s532 := allowance~address~address_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, tokenOwner_s532, spender_s532);
[L2217]  COND TRUE   !(__tmp___stopTrade_StreamProtocol[this] != true)
[L2218]              revert := true;
[L858]   RET         call remaining_s532 := allowance~address~address_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, tokenOwner_s532, spender_s532);
[L859]               assume revert || gas < 0;
[L3518]  RET         call remaining_s532 := allowance~address~address_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenOwner_s532, spender_s532);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:53,973 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:53,973 INFO  L82        PathProgramCache]: Analyzing trace with hash -239127474, now seen corresponding path program 1 times
[2020-11-25 05:48:53,974 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:53,982 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:54,032 INFO  L134       CoverageAnalysis]: Checked inductivity of 146 backedges. 2 proven. 96 refuted. 0 times theorem prover too weak. 48 trivial. 0 not checked.
[2020-11-25 05:48:54,032 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:54,032 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-11-25 05:48:54,033 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:54,033 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-11-25 05:48:54,033 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=20, Invalid=90, Unknown=0, NotChecked=0, Total=110
[2020-11-25 05:48:54,033 INFO  L87              Difference]: Start difference. First operand 3796 states and 4418 transitions. cyclomatic complexity: 634 Second operand 11 states.
[2020-11-25 05:48:55,047 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:55,047 INFO  L93              Difference]: Finished difference Result 6979 states and 8557 transitions.
[2020-11-25 05:48:55,048 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-11-25 05:48:55,048 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6979 states and 8557 transitions.
[2020-11-25 05:48:55,065 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 56
[2020-11-25 05:48:55,088 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6979 states to 6979 states and 8557 transitions.
[2020-11-25 05:48:55,088 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2318
[2020-11-25 05:48:55,090 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2318
[2020-11-25 05:48:55,090 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6979 states and 8557 transitions.
[2020-11-25 05:48:55,095 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:55,095 INFO  L728         BuchiCegarLoop]: Abstraction has 6979 states and 8557 transitions.
[2020-11-25 05:48:55,098 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6979 states and 8557 transitions.
[2020-11-25 05:48:55,147 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6979 to 6537.
[2020-11-25 05:48:55,147 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6537 states.
[2020-11-25 05:48:55,158 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6537 states to 6537 states and 8101 transitions.
[2020-11-25 05:48:55,158 INFO  L751         BuchiCegarLoop]: Abstraction has 6537 states and 8101 transitions.
[2020-11-25 05:48:55,158 INFO  L631         BuchiCegarLoop]: Abstraction has 6537 states and 8101 transitions.
[2020-11-25 05:48:55,158 INFO  L445         BuchiCegarLoop]: ======== Iteration 11============
[2020-11-25 05:48:55,158 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6537 states and 8101 transitions.
[2020-11-25 05:48:55,166 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 56
[2020-11-25 05:48:55,166 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:55,167 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:55,167 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:55,168 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND TRUE   !(__tmp___stopTrade_StreamProtocol[this] != true)
[L2032]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:55,171 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:55,171 INFO  L82        PathProgramCache]: Analyzing trace with hash -195409883, now seen corresponding path program 1 times
[2020-11-25 05:48:55,171 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:55,179 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:55,228 INFO  L134       CoverageAnalysis]: Checked inductivity of 151 backedges. 2 proven. 97 refuted. 0 times theorem prover too weak. 52 trivial. 0 not checked.
[2020-11-25 05:48:55,228 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:55,228 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-11-25 05:48:55,228 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:55,228 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-11-25 05:48:55,228 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=20, Invalid=90, Unknown=0, NotChecked=0, Total=110
[2020-11-25 05:48:55,229 INFO  L87              Difference]: Start difference. First operand 6537 states and 8101 transitions. cyclomatic complexity: 1592 Second operand 11 states.
[2020-11-25 05:48:56,280 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:56,280 INFO  L93              Difference]: Finished difference Result 6977 states and 8595 transitions.
[2020-11-25 05:48:56,280 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-11-25 05:48:56,280 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6977 states and 8595 transitions.
[2020-11-25 05:48:56,299 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 56
[2020-11-25 05:48:56,321 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6977 states to 6977 states and 8595 transitions.
[2020-11-25 05:48:56,322 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2325
[2020-11-25 05:48:56,323 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2325
[2020-11-25 05:48:56,323 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6977 states and 8595 transitions.
[2020-11-25 05:48:56,328 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:56,328 INFO  L728         BuchiCegarLoop]: Abstraction has 6977 states and 8595 transitions.
[2020-11-25 05:48:56,331 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6977 states and 8595 transitions.
[2020-11-25 05:48:56,375 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6977 to 6551.
[2020-11-25 05:48:56,375 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6551 states.
[2020-11-25 05:48:56,386 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6551 states to 6551 states and 8127 transitions.
[2020-11-25 05:48:56,387 INFO  L751         BuchiCegarLoop]: Abstraction has 6551 states and 8127 transitions.
[2020-11-25 05:48:56,387 INFO  L631         BuchiCegarLoop]: Abstraction has 6551 states and 8127 transitions.
[2020-11-25 05:48:56,387 INFO  L445         BuchiCegarLoop]: ======== Iteration 12============
[2020-11-25 05:48:56,387 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6551 states and 8127 transitions.
[2020-11-25 05:48:56,394 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 56
[2020-11-25 05:48:56,395 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:56,395 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:56,396 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:56,396 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND TRUE   choice == 11
[L3528]              gas := gas - 21000;
[L3529]  COND TRUE   gas >= 0
[L3530]              assume tokens_s419 >= 0 && tokens_s419 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3531]              assume msgvalue_MSG == 0;
[L3532]  CALL        call success_s419 := approve~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, spender_s419, tokens_s419);
[L724]               havoc __exception;
[L725]               revert := false;
[L726]   COND TRUE   __exception
[L727]               __tmp__Balance := Balance;
[L728]               __tmp__DType := DType;
[L729]               __tmp__Alloc := Alloc;
[L730]               __tmp__balance_ADDR := balance_ADDR;
[L731]               __tmp__M_Ref_int := M_Ref_int;
[L732]               __tmp__sum_balances0 := sum_balances0;
[L733]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L734]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L735]               __tmp__sum_allowed1 := sum_allowed1;
[L736]               __tmp__Length := Length;
[L737]               __tmp__now := now;
[L738]               __tmp__owner_Owned := owner_Owned;
[L739]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L740]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L741]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L742]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L743]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L744]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L745]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L746]   CALL        call success_s419 := approve~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, spender_s419, tokens_s419);
[L2093]  COND TRUE   !(__tmp___stopTrade_StreamProtocol[this] != true)
[L2094]              revert := true;
[L746]   RET         call success_s419 := approve~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, spender_s419, tokens_s419);
[L747]               assume revert || gas < 0;
[L3532]  RET         call success_s419 := approve~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, spender_s419, tokens_s419);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:56,399 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:56,399 INFO  L82        PathProgramCache]: Analyzing trace with hash -122378178, now seen corresponding path program 1 times
[2020-11-25 05:48:56,400 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:56,408 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:56,457 INFO  L134       CoverageAnalysis]: Checked inductivity of 152 backedges. 2 proven. 98 refuted. 0 times theorem prover too weak. 52 trivial. 0 not checked.
[2020-11-25 05:48:56,457 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:56,457 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [11] total 11
[2020-11-25 05:48:56,457 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:56,457 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 11 interpolants.
[2020-11-25 05:48:56,457 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=20, Invalid=90, Unknown=0, NotChecked=0, Total=110
[2020-11-25 05:48:56,458 INFO  L87              Difference]: Start difference. First operand 6551 states and 8127 transitions. cyclomatic complexity: 1604 Second operand 11 states.
[2020-11-25 05:48:57,357 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:57,357 INFO  L93              Difference]: Finished difference Result 6983 states and 8601 transitions.
[2020-11-25 05:48:57,357 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-11-25 05:48:57,357 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6983 states and 8601 transitions.
[2020-11-25 05:48:57,375 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 56
[2020-11-25 05:48:57,396 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6983 states to 6983 states and 8601 transitions.
[2020-11-25 05:48:57,397 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2328
[2020-11-25 05:48:57,398 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2328
[2020-11-25 05:48:57,398 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6983 states and 8601 transitions.
[2020-11-25 05:48:57,402 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:57,402 INFO  L728         BuchiCegarLoop]: Abstraction has 6983 states and 8601 transitions.
[2020-11-25 05:48:57,405 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6983 states and 8601 transitions.
[2020-11-25 05:48:57,448 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6983 to 6557.
[2020-11-25 05:48:57,448 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6557 states.
[2020-11-25 05:48:57,459 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6557 states to 6557 states and 8133 transitions.
[2020-11-25 05:48:57,459 INFO  L751         BuchiCegarLoop]: Abstraction has 6557 states and 8133 transitions.
[2020-11-25 05:48:57,459 INFO  L631         BuchiCegarLoop]: Abstraction has 6557 states and 8133 transitions.
[2020-11-25 05:48:57,460 INFO  L445         BuchiCegarLoop]: ======== Iteration 13============
[2020-11-25 05:48:57,460 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6557 states and 8133 transitions.
[2020-11-25 05:48:57,467 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 56
[2020-11-25 05:48:57,467 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:57,467 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:57,468 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:57,468 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:57,472 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:57,472 INFO  L82        PathProgramCache]: Analyzing trace with hash -979819447, now seen corresponding path program 1 times
[2020-11-25 05:48:57,472 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:57,485 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:57,624 INFO  L134       CoverageAnalysis]: Checked inductivity of 151 backedges. 10 proven. 9 refuted. 0 times theorem prover too weak. 132 trivial. 0 not checked.
[2020-11-25 05:48:57,624 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:57,624 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [26] total 26
[2020-11-25 05:48:57,625 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:57,625 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 27 interpolants.
[2020-11-25 05:48:57,625 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=66, Invalid=636, Unknown=0, NotChecked=0, Total=702
[2020-11-25 05:48:57,625 INFO  L87              Difference]: Start difference. First operand 6557 states and 8133 transitions. cyclomatic complexity: 1604 Second operand 27 states.
[2020-11-25 05:48:59,264 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:48:59,264 INFO  L93              Difference]: Finished difference Result 6620 states and 8122 transitions.
[2020-11-25 05:48:59,264 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 27 states. 
[2020-11-25 05:48:59,264 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6620 states and 8122 transitions.
[2020-11-25 05:48:59,279 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 36
[2020-11-25 05:48:59,299 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6620 states to 6620 states and 8122 transitions.
[2020-11-25 05:48:59,299 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2113
[2020-11-25 05:48:59,300 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2113
[2020-11-25 05:48:59,300 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6620 states and 8122 transitions.
[2020-11-25 05:48:59,304 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:48:59,304 INFO  L728         BuchiCegarLoop]: Abstraction has 6620 states and 8122 transitions.
[2020-11-25 05:48:59,306 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6620 states and 8122 transitions.
[2020-11-25 05:48:59,342 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6620 to 6577.
[2020-11-25 05:48:59,342 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6577 states.
[2020-11-25 05:48:59,352 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6577 states to 6577 states and 8069 transitions.
[2020-11-25 05:48:59,352 INFO  L751         BuchiCegarLoop]: Abstraction has 6577 states and 8069 transitions.
[2020-11-25 05:48:59,352 INFO  L631         BuchiCegarLoop]: Abstraction has 6577 states and 8069 transitions.
[2020-11-25 05:48:59,352 INFO  L445         BuchiCegarLoop]: ======== Iteration 14============
[2020-11-25 05:48:59,353 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6577 states and 8069 transitions.
[2020-11-25 05:48:59,360 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 36
[2020-11-25 05:48:59,360 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:48:59,360 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:48:59,361 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:48:59,361 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:48:59,363 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:48:59,363 INFO  L82        PathProgramCache]: Analyzing trace with hash 1061843215, now seen corresponding path program 1 times
[2020-11-25 05:48:59,364 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:48:59,376 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:48:59,526 INFO  L134       CoverageAnalysis]: Checked inductivity of 47 backedges. 0 proven. 1 refuted. 0 times theorem prover too weak. 46 trivial. 0 not checked.
[2020-11-25 05:48:59,526 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:48:59,526 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [28] total 28
[2020-11-25 05:48:59,526 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:48:59,526 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 29 interpolants.
[2020-11-25 05:48:59,527 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=68, Invalid=744, Unknown=0, NotChecked=0, Total=812
[2020-11-25 05:48:59,527 INFO  L87              Difference]: Start difference. First operand 6577 states and 8069 transitions. cyclomatic complexity: 1517 Second operand 29 states.
[2020-11-25 05:49:01,687 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:01,687 INFO  L93              Difference]: Finished difference Result 6665 states and 8089 transitions.
[2020-11-25 05:49:01,687 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 28 states. 
[2020-11-25 05:49:01,687 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6665 states and 8089 transitions.
[2020-11-25 05:49:01,701 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:01,718 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6665 states to 6665 states and 8089 transitions.
[2020-11-25 05:49:01,718 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2117
[2020-11-25 05:49:01,719 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2117
[2020-11-25 05:49:01,719 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6665 states and 8089 transitions.
[2020-11-25 05:49:01,723 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:01,723 INFO  L728         BuchiCegarLoop]: Abstraction has 6665 states and 8089 transitions.
[2020-11-25 05:49:01,725 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6665 states and 8089 transitions.
[2020-11-25 05:49:01,759 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6665 to 6545.
[2020-11-25 05:49:01,759 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6545 states.
[2020-11-25 05:49:01,769 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6545 states to 6545 states and 7932 transitions.
[2020-11-25 05:49:01,769 INFO  L751         BuchiCegarLoop]: Abstraction has 6545 states and 7932 transitions.
[2020-11-25 05:49:01,769 INFO  L631         BuchiCegarLoop]: Abstraction has 6545 states and 7932 transitions.
[2020-11-25 05:49:01,769 INFO  L445         BuchiCegarLoop]: ======== Iteration 15============
[2020-11-25 05:49:01,769 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6545 states and 7932 transitions.
[2020-11-25 05:49:01,776 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:01,776 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:01,776 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:01,777 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:01,777 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:01,781 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:01,781 INFO  L82        PathProgramCache]: Analyzing trace with hash 578902919, now seen corresponding path program 1 times
[2020-11-25 05:49:01,782 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:01,799 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:01,996 INFO  L134       CoverageAnalysis]: Checked inductivity of 324 backedges. 149 proven. 21 refuted. 0 times theorem prover too weak. 154 trivial. 0 not checked.
[2020-11-25 05:49:01,996 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:01,996 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [31] total 31
[2020-11-25 05:49:01,996 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:01,996 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 32 interpolants.
[2020-11-25 05:49:01,997 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=94, Invalid=898, Unknown=0, NotChecked=0, Total=992
[2020-11-25 05:49:01,997 INFO  L87              Difference]: Start difference. First operand 6545 states and 7932 transitions. cyclomatic complexity: 1408 Second operand 32 states.
[2020-11-25 05:49:03,296 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:03,296 INFO  L93              Difference]: Finished difference Result 6620 states and 8222 transitions.
[2020-11-25 05:49:03,296 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 30 states. 
[2020-11-25 05:49:03,297 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6620 states and 8222 transitions.
[2020-11-25 05:49:03,314 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 40
[2020-11-25 05:49:03,335 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6620 states to 6620 states and 8222 transitions.
[2020-11-25 05:49:03,335 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2109
[2020-11-25 05:49:03,336 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2109
[2020-11-25 05:49:03,336 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6620 states and 8222 transitions.
[2020-11-25 05:49:03,340 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:03,340 INFO  L728         BuchiCegarLoop]: Abstraction has 6620 states and 8222 transitions.
[2020-11-25 05:49:03,343 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6620 states and 8222 transitions.
[2020-11-25 05:49:03,381 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6620 to 6611.
[2020-11-25 05:49:03,381 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6611 states.
[2020-11-25 05:49:03,393 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6611 states to 6611 states and 8207 transitions.
[2020-11-25 05:49:03,393 INFO  L751         BuchiCegarLoop]: Abstraction has 6611 states and 8207 transitions.
[2020-11-25 05:49:03,393 INFO  L631         BuchiCegarLoop]: Abstraction has 6611 states and 8207 transitions.
[2020-11-25 05:49:03,393 INFO  L445         BuchiCegarLoop]: ======== Iteration 16============
[2020-11-25 05:49:03,393 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6611 states and 8207 transitions.
[2020-11-25 05:49:03,401 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 40
[2020-11-25 05:49:03,401 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:03,401 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:03,402 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:03,402 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:03,406 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:03,406 INFO  L82        PathProgramCache]: Analyzing trace with hash -1573478374, now seen corresponding path program 1 times
[2020-11-25 05:49:03,406 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:03,425 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:03,683 INFO  L134       CoverageAnalysis]: Checked inductivity of 324 backedges. 25 proven. 21 refuted. 0 times theorem prover too weak. 278 trivial. 0 not checked.
[2020-11-25 05:49:03,683 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:03,683 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [30] total 30
[2020-11-25 05:49:03,683 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:03,683 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 31 interpolants.
[2020-11-25 05:49:03,683 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=85, Invalid=845, Unknown=0, NotChecked=0, Total=930
[2020-11-25 05:49:03,684 INFO  L87              Difference]: Start difference. First operand 6611 states and 8207 transitions. cyclomatic complexity: 1623 Second operand 31 states.
[2020-11-25 05:49:05,285 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:05,285 INFO  L93              Difference]: Finished difference Result 6618 states and 8114 transitions.
[2020-11-25 05:49:05,285 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 30 states. 
[2020-11-25 05:49:05,285 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6618 states and 8114 transitions.
[2020-11-25 05:49:05,301 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:05,318 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6618 states to 6618 states and 8114 transitions.
[2020-11-25 05:49:05,318 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2089
[2020-11-25 05:49:05,319 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2089
[2020-11-25 05:49:05,319 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6618 states and 8114 transitions.
[2020-11-25 05:49:05,323 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:05,323 INFO  L728         BuchiCegarLoop]: Abstraction has 6618 states and 8114 transitions.
[2020-11-25 05:49:05,326 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6618 states and 8114 transitions.
[2020-11-25 05:49:05,363 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6618 to 6545.
[2020-11-25 05:49:05,363 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6545 states.
[2020-11-25 05:49:05,373 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6545 states to 6545 states and 7932 transitions.
[2020-11-25 05:49:05,373 INFO  L751         BuchiCegarLoop]: Abstraction has 6545 states and 7932 transitions.
[2020-11-25 05:49:05,373 INFO  L631         BuchiCegarLoop]: Abstraction has 6545 states and 7932 transitions.
[2020-11-25 05:49:05,373 INFO  L445         BuchiCegarLoop]: ======== Iteration 17============
[2020-11-25 05:49:05,373 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6545 states and 7932 transitions.
[2020-11-25 05:49:05,380 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:05,380 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:05,380 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:05,381 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:05,382 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:05,385 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:05,385 INFO  L82        PathProgramCache]: Analyzing trace with hash -1430311091, now seen corresponding path program 1 times
[2020-11-25 05:49:05,386 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:05,399 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:05,655 INFO  L134       CoverageAnalysis]: Checked inductivity of 314 backedges. 183 proven. 30 refuted. 0 times theorem prover too weak. 101 trivial. 0 not checked.
[2020-11-25 05:49:05,655 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:05,655 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [34] total 34
[2020-11-25 05:49:05,656 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:05,656 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 35 interpolants.
[2020-11-25 05:49:05,656 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=99, Invalid=1091, Unknown=0, NotChecked=0, Total=1190
[2020-11-25 05:49:05,656 INFO  L87              Difference]: Start difference. First operand 6545 states and 7932 transitions. cyclomatic complexity: 1408 Second operand 35 states.
[2020-11-25 05:49:07,137 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:07,137 INFO  L93              Difference]: Finished difference Result 6642 states and 8349 transitions.
[2020-11-25 05:49:07,137 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 33 states. 
[2020-11-25 05:49:07,137 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6642 states and 8349 transitions.
[2020-11-25 05:49:07,155 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 40
[2020-11-25 05:49:07,173 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6642 states to 6642 states and 8349 transitions.
[2020-11-25 05:49:07,173 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2109
[2020-11-25 05:49:07,174 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2109
[2020-11-25 05:49:07,174 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6642 states and 8349 transitions.
[2020-11-25 05:49:07,179 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:07,179 INFO  L728         BuchiCegarLoop]: Abstraction has 6642 states and 8349 transitions.
[2020-11-25 05:49:07,181 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6642 states and 8349 transitions.
[2020-11-25 05:49:07,218 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6642 to 6633.
[2020-11-25 05:49:07,218 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6633 states.
[2020-11-25 05:49:07,229 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6633 states to 6633 states and 8334 transitions.
[2020-11-25 05:49:07,230 INFO  L751         BuchiCegarLoop]: Abstraction has 6633 states and 8334 transitions.
[2020-11-25 05:49:07,230 INFO  L631         BuchiCegarLoop]: Abstraction has 6633 states and 8334 transitions.
[2020-11-25 05:49:07,230 INFO  L445         BuchiCegarLoop]: ======== Iteration 18============
[2020-11-25 05:49:07,230 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6633 states and 8334 transitions.
[2020-11-25 05:49:07,237 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 40
[2020-11-25 05:49:07,237 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:07,237 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:07,238 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:07,238 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:07,242 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:07,242 INFO  L82        PathProgramCache]: Analyzing trace with hash 1336151904, now seen corresponding path program 1 times
[2020-11-25 05:49:07,242 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:07,257 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:07,478 INFO  L134       CoverageAnalysis]: Checked inductivity of 314 backedges. 24 proven. 17 refuted. 0 times theorem prover too weak. 273 trivial. 0 not checked.
[2020-11-25 05:49:07,478 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:07,478 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [33] total 33
[2020-11-25 05:49:07,479 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:07,479 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 34 interpolants.
[2020-11-25 05:49:07,479 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=98, Invalid=1024, Unknown=0, NotChecked=0, Total=1122
[2020-11-25 05:49:07,479 INFO  L87              Difference]: Start difference. First operand 6633 states and 8334 transitions. cyclomatic complexity: 1731 Second operand 34 states.
[2020-11-25 05:49:09,332 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:09,333 INFO  L93              Difference]: Finished difference Result 6640 states and 8241 transitions.
[2020-11-25 05:49:09,333 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 34 states. 
[2020-11-25 05:49:09,333 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6640 states and 8241 transitions.
[2020-11-25 05:49:09,350 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:09,370 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6640 states to 6640 states and 8241 transitions.
[2020-11-25 05:49:09,370 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2089
[2020-11-25 05:49:09,371 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2089
[2020-11-25 05:49:09,371 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6640 states and 8241 transitions.
[2020-11-25 05:49:09,376 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:09,376 INFO  L728         BuchiCegarLoop]: Abstraction has 6640 states and 8241 transitions.
[2020-11-25 05:49:09,378 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6640 states and 8241 transitions.
[2020-11-25 05:49:09,413 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6640 to 6589.
[2020-11-25 05:49:09,413 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6589 states.
[2020-11-25 05:49:09,424 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6589 states to 6589 states and 8182 transitions.
[2020-11-25 05:49:09,424 INFO  L751         BuchiCegarLoop]: Abstraction has 6589 states and 8182 transitions.
[2020-11-25 05:49:09,424 INFO  L631         BuchiCegarLoop]: Abstraction has 6589 states and 8182 transitions.
[2020-11-25 05:49:09,424 INFO  L445         BuchiCegarLoop]: ======== Iteration 19============
[2020-11-25 05:49:09,424 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6589 states and 8182 transitions.
[2020-11-25 05:49:09,432 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:09,432 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:09,432 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:09,432 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:09,432 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:09,435 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:09,435 INFO  L82        PathProgramCache]: Analyzing trace with hash -118954250, now seen corresponding path program 1 times
[2020-11-25 05:49:09,435 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:09,447 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:09,647 INFO  L134       CoverageAnalysis]: Checked inductivity of 47 backedges. 0 proven. 1 refuted. 0 times theorem prover too weak. 46 trivial. 0 not checked.
[2020-11-25 05:49:09,648 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:09,648 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [28] total 28
[2020-11-25 05:49:09,648 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:09,648 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 29 interpolants.
[2020-11-25 05:49:09,648 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=69, Invalid=743, Unknown=0, NotChecked=0, Total=812
[2020-11-25 05:49:09,649 INFO  L87              Difference]: Start difference. First operand 6589 states and 8182 transitions. cyclomatic complexity: 1620 Second operand 29 states.
[2020-11-25 05:49:11,720 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:11,720 INFO  L93              Difference]: Finished difference Result 6689 states and 8471 transitions.
[2020-11-25 05:49:11,720 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 29 states. 
[2020-11-25 05:49:11,720 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6689 states and 8471 transitions.
[2020-11-25 05:49:11,738 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 32
[2020-11-25 05:49:11,757 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6689 states to 6689 states and 8471 transitions.
[2020-11-25 05:49:11,757 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2109
[2020-11-25 05:49:11,758 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2109
[2020-11-25 05:49:11,758 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6689 states and 8471 transitions.
[2020-11-25 05:49:11,763 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:11,763 INFO  L728         BuchiCegarLoop]: Abstraction has 6689 states and 8471 transitions.
[2020-11-25 05:49:11,765 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6689 states and 8471 transitions.
[2020-11-25 05:49:11,799 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6689 to 6655.
[2020-11-25 05:49:11,800 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6655 states.
[2020-11-25 05:49:11,811 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6655 states to 6655 states and 8424 transitions.
[2020-11-25 05:49:11,811 INFO  L751         BuchiCegarLoop]: Abstraction has 6655 states and 8424 transitions.
[2020-11-25 05:49:11,811 INFO  L631         BuchiCegarLoop]: Abstraction has 6655 states and 8424 transitions.
[2020-11-25 05:49:11,811 INFO  L445         BuchiCegarLoop]: ======== Iteration 20============
[2020-11-25 05:49:11,811 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6655 states and 8424 transitions.
[2020-11-25 05:49:11,818 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 32
[2020-11-25 05:49:11,818 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:11,818 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:11,819 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:11,819 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:11,821 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:11,822 INFO  L82        PathProgramCache]: Analyzing trace with hash 290484579, now seen corresponding path program 1 times
[2020-11-25 05:49:11,822 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:11,832 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:11,991 INFO  L134       CoverageAnalysis]: Checked inductivity of 47 backedges. 0 proven. 1 refuted. 0 times theorem prover too weak. 46 trivial. 0 not checked.
[2020-11-25 05:49:11,991 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:11,991 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [28] total 28
[2020-11-25 05:49:11,991 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:11,991 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 29 interpolants.
[2020-11-25 05:49:11,991 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=69, Invalid=743, Unknown=0, NotChecked=0, Total=812
[2020-11-25 05:49:11,991 INFO  L87              Difference]: Start difference. First operand 6655 states and 8424 transitions. cyclomatic complexity: 1802 Second operand 29 states.
[2020-11-25 05:49:15,037 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:15,038 INFO  L93              Difference]: Finished difference Result 7477 states and 9187 transitions.
[2020-11-25 05:49:15,038 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 39 states. 
[2020-11-25 05:49:15,038 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7477 states and 9187 transitions.
[2020-11-25 05:49:15,056 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:15,076 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7477 states to 7477 states and 9187 transitions.
[2020-11-25 05:49:15,077 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2483
[2020-11-25 05:49:15,077 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2483
[2020-11-25 05:49:15,078 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7477 states and 9187 transitions.
[2020-11-25 05:49:15,083 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:15,083 INFO  L728         BuchiCegarLoop]: Abstraction has 7477 states and 9187 transitions.
[2020-11-25 05:49:15,085 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7477 states and 9187 transitions.
[2020-11-25 05:49:15,121 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7477 to 6635.
[2020-11-25 05:49:15,121 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6635 states.
[2020-11-25 05:49:15,132 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6635 states to 6635 states and 8328 transitions.
[2020-11-25 05:49:15,132 INFO  L751         BuchiCegarLoop]: Abstraction has 6635 states and 8328 transitions.
[2020-11-25 05:49:15,132 INFO  L631         BuchiCegarLoop]: Abstraction has 6635 states and 8328 transitions.
[2020-11-25 05:49:15,132 INFO  L445         BuchiCegarLoop]: ======== Iteration 21============
[2020-11-25 05:49:15,133 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6635 states and 8328 transitions.
[2020-11-25 05:49:15,140 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:15,140 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:15,140 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:15,141 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:15,141 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:15,144 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:15,144 INFO  L82        PathProgramCache]: Analyzing trace with hash 2109872519, now seen corresponding path program 1 times
[2020-11-25 05:49:15,145 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:15,162 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:15,434 INFO  L134       CoverageAnalysis]: Checked inductivity of 322 backedges. 10 proven. 38 refuted. 0 times theorem prover too weak. 274 trivial. 0 not checked.
[2020-11-25 05:49:15,434 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:15,434 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [35] total 35
[2020-11-25 05:49:15,434 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:15,435 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 36 interpolants.
[2020-11-25 05:49:15,435 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=108, Invalid=1152, Unknown=0, NotChecked=0, Total=1260
[2020-11-25 05:49:15,435 INFO  L87              Difference]: Start difference. First operand 6635 states and 8328 transitions. cyclomatic complexity: 1724 Second operand 36 states.
[2020-11-25 05:49:17,344 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:17,344 INFO  L93              Difference]: Finished difference Result 6709 states and 8616 transitions.
[2020-11-25 05:49:17,345 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 34 states. 
[2020-11-25 05:49:17,345 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6709 states and 8616 transitions.
[2020-11-25 05:49:17,365 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 38
[2020-11-25 05:49:17,386 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6709 states to 6709 states and 8616 transitions.
[2020-11-25 05:49:17,386 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2107
[2020-11-25 05:49:17,387 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2107
[2020-11-25 05:49:17,387 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6709 states and 8616 transitions.
[2020-11-25 05:49:17,392 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:17,392 INFO  L728         BuchiCegarLoop]: Abstraction has 6709 states and 8616 transitions.
[2020-11-25 05:49:17,394 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6709 states and 8616 transitions.
[2020-11-25 05:49:17,431 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6709 to 6681.
[2020-11-25 05:49:17,431 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6681 states.
[2020-11-25 05:49:17,444 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6681 states to 6681 states and 8583 transitions.
[2020-11-25 05:49:17,444 INFO  L751         BuchiCegarLoop]: Abstraction has 6681 states and 8583 transitions.
[2020-11-25 05:49:17,444 INFO  L631         BuchiCegarLoop]: Abstraction has 6681 states and 8583 transitions.
[2020-11-25 05:49:17,444 INFO  L445         BuchiCegarLoop]: ======== Iteration 22============
[2020-11-25 05:49:17,444 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6681 states and 8583 transitions.
[2020-11-25 05:49:17,452 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 38
[2020-11-25 05:49:17,452 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:17,452 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:17,453 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:17,453 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:17,456 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:17,456 INFO  L82        PathProgramCache]: Analyzing trace with hash 1718702644, now seen corresponding path program 1 times
[2020-11-25 05:49:17,457 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:17,470 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:17,773 INFO  L134       CoverageAnalysis]: Checked inductivity of 322 backedges. 183 proven. 38 refuted. 0 times theorem prover too weak. 101 trivial. 0 not checked.
[2020-11-25 05:49:17,773 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:17,773 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [35] total 35
[2020-11-25 05:49:17,773 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:17,773 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 36 interpolants.
[2020-11-25 05:49:17,774 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=111, Invalid=1149, Unknown=0, NotChecked=0, Total=1260
[2020-11-25 05:49:17,774 INFO  L87              Difference]: Start difference. First operand 6681 states and 8583 transitions. cyclomatic complexity: 1938 Second operand 36 states.
[2020-11-25 05:49:19,205 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:19,205 INFO  L93              Difference]: Finished difference Result 6688 states and 8497 transitions.
[2020-11-25 05:49:19,205 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 34 states. 
[2020-11-25 05:49:19,205 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6688 states and 8497 transitions.
[2020-11-25 05:49:19,224 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:19,244 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6688 states to 6688 states and 8497 transitions.
[2020-11-25 05:49:19,244 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2089
[2020-11-25 05:49:19,245 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2089
[2020-11-25 05:49:19,245 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6688 states and 8497 transitions.
[2020-11-25 05:49:19,250 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:19,250 INFO  L728         BuchiCegarLoop]: Abstraction has 6688 states and 8497 transitions.
[2020-11-25 05:49:19,252 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6688 states and 8497 transitions.
[2020-11-25 05:49:19,287 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6688 to 6655.
[2020-11-25 05:49:19,287 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6655 states.
[2020-11-25 05:49:19,300 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6655 states to 6655 states and 8456 transitions.
[2020-11-25 05:49:19,300 INFO  L751         BuchiCegarLoop]: Abstraction has 6655 states and 8456 transitions.
[2020-11-25 05:49:19,300 INFO  L631         BuchiCegarLoop]: Abstraction has 6655 states and 8456 transitions.
[2020-11-25 05:49:19,300 INFO  L445         BuchiCegarLoop]: ======== Iteration 23============
[2020-11-25 05:49:19,300 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6655 states and 8456 transitions.
[2020-11-25 05:49:19,307 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:19,307 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:19,307 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:19,308 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:19,308 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !(_totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936);
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:19,310 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:19,310 INFO  L82        PathProgramCache]: Analyzing trace with hash 373824203, now seen corresponding path program 1 times
[2020-11-25 05:49:19,311 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:19,321 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:19,522 INFO  L134       CoverageAnalysis]: Checked inductivity of 155 backedges. 10 proven. 10 refuted. 0 times theorem prover too weak. 135 trivial. 0 not checked.
[2020-11-25 05:49:19,522 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:19,522 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [33] total 33
[2020-11-25 05:49:19,523 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:19,523 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 34 interpolants.
[2020-11-25 05:49:19,523 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=92, Invalid=1030, Unknown=0, NotChecked=0, Total=1122
[2020-11-25 05:49:19,523 INFO  L87              Difference]: Start difference. First operand 6655 states and 8456 transitions. cyclomatic complexity: 1835 Second operand 34 states.
[2020-11-25 05:49:23,956 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:23,956 INFO  L93              Difference]: Finished difference Result 7525 states and 9509 transitions.
[2020-11-25 05:49:23,956 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 50 states. 
[2020-11-25 05:49:23,956 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7525 states and 9509 transitions.
[2020-11-25 05:49:23,978 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 36
[2020-11-25 05:49:24,002 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7525 states to 7525 states and 9509 transitions.
[2020-11-25 05:49:24,002 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2495
[2020-11-25 05:49:24,003 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2495
[2020-11-25 05:49:24,003 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7525 states and 9509 transitions.
[2020-11-25 05:49:24,008 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:24,008 INFO  L728         BuchiCegarLoop]: Abstraction has 7525 states and 9509 transitions.
[2020-11-25 05:49:24,011 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7525 states and 9509 transitions.
[2020-11-25 05:49:24,050 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7525 to 6703.
[2020-11-25 05:49:24,050 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6703 states.
[2020-11-25 05:49:24,064 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6703 states to 6703 states and 8682 transitions.
[2020-11-25 05:49:24,064 INFO  L751         BuchiCegarLoop]: Abstraction has 6703 states and 8682 transitions.
[2020-11-25 05:49:24,064 INFO  L631         BuchiCegarLoop]: Abstraction has 6703 states and 8682 transitions.
[2020-11-25 05:49:24,064 INFO  L445         BuchiCegarLoop]: ======== Iteration 24============
[2020-11-25 05:49:24,064 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6703 states and 8682 transitions.
[2020-11-25 05:49:24,071 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 36
[2020-11-25 05:49:24,071 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:24,071 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:24,072 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:24,072 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:24,074 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:24,074 INFO  L82        PathProgramCache]: Analyzing trace with hash -117987746, now seen corresponding path program 1 times
[2020-11-25 05:49:24,075 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:24,094 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:24,380 INFO  L134       CoverageAnalysis]: Checked inductivity of 155 backedges. 10 proven. 10 refuted. 0 times theorem prover too weak. 135 trivial. 0 not checked.
[2020-11-25 05:49:24,380 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:24,380 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [33] total 33
[2020-11-25 05:49:24,380 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:24,380 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 34 interpolants.
[2020-11-25 05:49:24,381 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=92, Invalid=1030, Unknown=0, NotChecked=0, Total=1122
[2020-11-25 05:49:24,381 INFO  L87              Difference]: Start difference. First operand 6703 states and 8682 transitions. cyclomatic complexity: 2021 Second operand 34 states.
[2020-11-25 05:49:26,779 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:26,779 INFO  L93              Difference]: Finished difference Result 6789 states and 8695 transitions.
[2020-11-25 05:49:26,779 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 32 states. 
[2020-11-25 05:49:26,779 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6789 states and 8695 transitions.
[2020-11-25 05:49:26,799 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:26,820 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6789 states to 6789 states and 8695 transitions.
[2020-11-25 05:49:26,820 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2117
[2020-11-25 05:49:26,821 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2117
[2020-11-25 05:49:26,821 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6789 states and 8695 transitions.
[2020-11-25 05:49:26,826 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:26,826 INFO  L728         BuchiCegarLoop]: Abstraction has 6789 states and 8695 transitions.
[2020-11-25 05:49:26,828 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6789 states and 8695 transitions.
[2020-11-25 05:49:26,864 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6789 to 6671.
[2020-11-25 05:49:26,864 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6671 states.
[2020-11-25 05:49:26,876 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6671 states to 6671 states and 8537 transitions.
[2020-11-25 05:49:26,876 INFO  L751         BuchiCegarLoop]: Abstraction has 6671 states and 8537 transitions.
[2020-11-25 05:49:26,876 INFO  L631         BuchiCegarLoop]: Abstraction has 6671 states and 8537 transitions.
[2020-11-25 05:49:26,876 INFO  L445         BuchiCegarLoop]: ======== Iteration 25============
[2020-11-25 05:49:26,876 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6671 states and 8537 transitions.
[2020-11-25 05:49:26,883 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:26,883 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:26,883 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:26,884 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:26,884 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:26,886 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:26,886 INFO  L82        PathProgramCache]: Analyzing trace with hash 918664903, now seen corresponding path program 1 times
[2020-11-25 05:49:26,887 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:26,903 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:27,200 INFO  L134       CoverageAnalysis]: Checked inductivity of 176 backedges. 0 proven. 39 refuted. 0 times theorem prover too weak. 137 trivial. 0 not checked.
[2020-11-25 05:49:27,200 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:27,200 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [38] total 38
[2020-11-25 05:49:27,200 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:27,200 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 39 interpolants.
[2020-11-25 05:49:27,201 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=122, Invalid=1360, Unknown=0, NotChecked=0, Total=1482
[2020-11-25 05:49:27,201 INFO  L87              Difference]: Start difference. First operand 6671 states and 8537 transitions. cyclomatic complexity: 1904 Second operand 39 states.
[2020-11-25 05:49:29,811 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:29,812 INFO  L93              Difference]: Finished difference Result 6749 states and 8791 transitions.
[2020-11-25 05:49:29,812 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 34 states. 
[2020-11-25 05:49:29,812 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6749 states and 8791 transitions.
[2020-11-25 05:49:29,831 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 32
[2020-11-25 05:49:29,853 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6749 states to 6749 states and 8791 transitions.
[2020-11-25 05:49:29,853 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2117
[2020-11-25 05:49:29,854 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2117
[2020-11-25 05:49:29,854 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6749 states and 8791 transitions.
[2020-11-25 05:49:29,860 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:29,860 INFO  L728         BuchiCegarLoop]: Abstraction has 6749 states and 8791 transitions.
[2020-11-25 05:49:29,862 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6749 states and 8791 transitions.
[2020-11-25 05:49:29,899 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6749 to 6707.
[2020-11-25 05:49:29,899 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6707 states.
[2020-11-25 05:49:29,912 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6707 states to 6707 states and 8722 transitions.
[2020-11-25 05:49:29,912 INFO  L751         BuchiCegarLoop]: Abstraction has 6707 states and 8722 transitions.
[2020-11-25 05:49:29,912 INFO  L631         BuchiCegarLoop]: Abstraction has 6707 states and 8722 transitions.
[2020-11-25 05:49:29,912 INFO  L445         BuchiCegarLoop]: ======== Iteration 26============
[2020-11-25 05:49:29,912 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6707 states and 8722 transitions.
[2020-11-25 05:49:29,919 INFO  L131   ngComponentsAnalysis]: Automaton has 5 accepting balls. 32
[2020-11-25 05:49:29,920 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:29,920 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:29,920 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:29,920 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:29,923 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:29,923 INFO  L82        PathProgramCache]: Analyzing trace with hash -63651980, now seen corresponding path program 1 times
[2020-11-25 05:49:29,923 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:29,936 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:30,189 INFO  L134       CoverageAnalysis]: Checked inductivity of 176 backedges. 0 proven. 39 refuted. 0 times theorem prover too weak. 137 trivial. 0 not checked.
[2020-11-25 05:49:30,189 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:30,189 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [38] total 38
[2020-11-25 05:49:30,190 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:30,190 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 39 interpolants.
[2020-11-25 05:49:30,190 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=122, Invalid=1360, Unknown=0, NotChecked=0, Total=1482
[2020-11-25 05:49:30,190 INFO  L87              Difference]: Start difference. First operand 6707 states and 8722 transitions. cyclomatic complexity: 2059 Second operand 39 states.
[2020-11-25 05:49:33,926 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:33,926 INFO  L93              Difference]: Finished difference Result 7537 states and 9499 transitions.
[2020-11-25 05:49:33,926 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 48 states. 
[2020-11-25 05:49:33,926 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7537 states and 9499 transitions.
[2020-11-25 05:49:33,948 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:33,971 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7537 states to 7537 states and 9499 transitions.
[2020-11-25 05:49:33,971 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2491
[2020-11-25 05:49:33,972 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2491
[2020-11-25 05:49:33,972 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7537 states and 9499 transitions.
[2020-11-25 05:49:33,977 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:33,977 INFO  L728         BuchiCegarLoop]: Abstraction has 7537 states and 9499 transitions.
[2020-11-25 05:49:33,980 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7537 states and 9499 transitions.
[2020-11-25 05:49:34,016 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7537 to 6687.
[2020-11-25 05:49:34,016 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6687 states.
[2020-11-25 05:49:34,028 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6687 states to 6687 states and 8626 transitions.
[2020-11-25 05:49:34,028 INFO  L751         BuchiCegarLoop]: Abstraction has 6687 states and 8626 transitions.
[2020-11-25 05:49:34,028 INFO  L631         BuchiCegarLoop]: Abstraction has 6687 states and 8626 transitions.
[2020-11-25 05:49:34,028 INFO  L445         BuchiCegarLoop]: ======== Iteration 27============
[2020-11-25 05:49:34,029 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6687 states and 8626 transitions.
[2020-11-25 05:49:34,036 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 20
[2020-11-25 05:49:34,036 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:34,036 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:34,036 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:34,036 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL       call CorralChoice_StreamProtocol(this);
[L3458]             havoc msgsender_MSG;
[L3459]             havoc msgvalue_MSG;
[L3460]             havoc choice;
[L3461]             havoc __ret_0_totalSupply;
[L3462]             havoc tokenOwner_s328;
[L3463]             havoc balance_s328;
[L3464]             havoc tokenOwner_s532;
[L3465]             havoc spender_s532;
[L3466]             havoc remaining_s532;
[L3467]             havoc to_s385;
[L3468]             havoc tokens_s385;
[L3469]             havoc success_s385;
[L3470]             havoc spender_s419;
[L3471]             havoc tokens_s419;
[L3472]             havoc success_s419;
[L3473]             havoc from_s510;
[L3474]             havoc to_s510;
[L3475]             havoc tokens_s510;
[L3476]             havoc success_s510;
[L3477]             havoc __ret_0_owner;
[L3478]             havoc __ret_0_symbol;
[L3479]             havoc __ret_0_name;
[L3480]             havoc __ret_0_decimals;
[L3481]             havoc spender_s582;
[L3482]             havoc tokens_s582;
[L3483]             havoc data_s582;
[L3484]             havoc success_s582;
[L3485]             havoc tokenAddress_s609;
[L3486]             havoc tokens_s609;
[L3487]             havoc success_s609;
[L3488]             havoc _value_s658;
[L3489]             havoc tmpNow;
[L3490]             havoc gas;
[L3491]             assume gas > 4000000 && gas <= 8000000;
[L3492]             tmpNow := now;
[L3493]             havoc now;
[L3494]             assume now > tmpNow;
[L3495]             assume msgsender_MSG != null;
[L3496]             assume DType[msgsender_MSG] != SafeMath;
[L3497]             assume DType[msgsender_MSG] != ERC20Interface;
[L3498]             assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]             assume DType[msgsender_MSG] != Owned;
[L3500]             assume DType[msgsender_MSG] != StreamProtocol;
[L3501]             Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE  choice == 15
[L3503]             gas := gas - 21000;
[L3504]  COND TRUE  gas >= 0
[L3505]             assume msgvalue_MSG == 0;
[L3506]  CALL       call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                revert_hold := revert;
[L2]                revert := false;
[L2]                assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                call_totalSupply_StreamProtocol0 := true;
[L2]                call_totalSupply_StreamProtocol0 := false;
[L2]                revert := revert_hold;
[L448]              havoc __exception;
[L449]              revert := false;
[L450]   COND TRUE  __exception
[L451]              __tmp__Balance := Balance;
[L452]              __tmp__DType := DType;
[L453]              __tmp__Alloc := Alloc;
[L454]              __tmp__balance_ADDR := balance_ADDR;
[L455]              __tmp__M_Ref_int := M_Ref_int;
[L456]              __tmp__sum_balances0 := sum_balances0;
[L457]              __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]              __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]              __tmp__sum_allowed1 := sum_allowed1;
[L460]              __tmp__Length := Length;
[L461]              __tmp__now := now;
[L462]              __tmp__owner_Owned := owner_Owned;
[L463]              __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]              __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]              __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]              __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]              __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]              __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]              __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL       call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]             __var_3 := null;
[L1941]  CALL       call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE  !(b_s45 <= a_s45)
[L1684]             revert := true;
[L1941]  RET        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE  revert
[L470]   RET        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]              assume revert || gas < 0;
[L3506]  RET        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET        call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:34,039 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:34,039 INFO  L82        PathProgramCache]: Analyzing trace with hash 820825518, now seen corresponding path program 1 times
[2020-11-25 05:49:34,040 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:34,051 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:34,304 INFO  L134       CoverageAnalysis]: Checked inductivity of 157 backedges. 0 proven. 6 refuted. 0 times theorem prover too weak. 151 trivial. 0 not checked.
[2020-11-25 05:49:34,304 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:34,304 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [36] total 36
[2020-11-25 05:49:34,305 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:34,305 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 37 interpolants.
[2020-11-25 05:49:34,305 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=103, Invalid=1229, Unknown=0, NotChecked=0, Total=1332
[2020-11-25 05:49:34,305 INFO  L87              Difference]: Start difference. First operand 6687 states and 8626 transitions. cyclomatic complexity: 1981 Second operand 37 states.
[2020-11-25 05:49:36,366 WARN  L188               SmtUtils]: Spent 172.00 ms on a formula simplification that was a NOOP. DAG size: 80
[2020-11-25 05:49:39,110 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:39,111 INFO  L93              Difference]: Finished difference Result 7565 states and 9701 transitions.
[2020-11-25 05:49:39,111 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 52 states. 
[2020-11-25 05:49:39,111 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 7565 states and 9701 transitions.
[2020-11-25 05:49:39,134 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 36
[2020-11-25 05:49:39,160 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 7565 states to 7565 states and 9701 transitions.
[2020-11-25 05:49:39,160 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2503
[2020-11-25 05:49:39,161 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2503
[2020-11-25 05:49:39,161 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 7565 states and 9701 transitions.
[2020-11-25 05:49:39,167 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:39,167 INFO  L728         BuchiCegarLoop]: Abstraction has 7565 states and 9701 transitions.
[2020-11-25 05:49:39,169 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 7565 states and 9701 transitions.
[2020-11-25 05:49:39,208 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 7565 to 6727.
[2020-11-25 05:49:39,208 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6727 states.
[2020-11-25 05:49:39,222 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6727 states to 6727 states and 8844 transitions.
[2020-11-25 05:49:39,222 INFO  L751         BuchiCegarLoop]: Abstraction has 6727 states and 8844 transitions.
[2020-11-25 05:49:39,222 INFO  L631         BuchiCegarLoop]: Abstraction has 6727 states and 8844 transitions.
[2020-11-25 05:49:39,222 INFO  L445         BuchiCegarLoop]: ======== Iteration 28============
[2020-11-25 05:49:39,222 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6727 states and 8844 transitions.
[2020-11-25 05:49:39,229 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 36
[2020-11-25 05:49:39,229 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:39,229 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:39,230 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:39,231 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !(_totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936);
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:39,234 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:39,234 INFO  L82        PathProgramCache]: Analyzing trace with hash 440204316, now seen corresponding path program 1 times
[2020-11-25 05:49:39,235 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:39,251 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:39,575 INFO  L134       CoverageAnalysis]: Checked inductivity of 548 backedges. 280 proven. 54 refuted. 0 times theorem prover too weak. 214 trivial. 0 not checked.
[2020-11-25 05:49:39,575 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:39,575 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [39] total 39
[2020-11-25 05:49:39,575 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:39,575 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 40 interpolants.
[2020-11-25 05:49:39,576 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=132, Invalid=1428, Unknown=0, NotChecked=0, Total=1560
[2020-11-25 05:49:39,576 INFO  L87              Difference]: Start difference. First operand 6727 states and 8844 transitions. cyclomatic complexity: 2167 Second operand 40 states.
[2020-11-25 05:49:41,716 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:41,716 INFO  L93              Difference]: Finished difference Result 6800 states and 9167 transitions.
[2020-11-25 05:49:41,716 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 37 states. 
[2020-11-25 05:49:41,717 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6800 states and 9167 transitions.
[2020-11-25 05:49:41,757 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 56
[2020-11-25 05:49:41,786 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6800 states to 6800 states and 9167 transitions.
[2020-11-25 05:49:41,786 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2133
[2020-11-25 05:49:41,787 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2133
[2020-11-25 05:49:41,787 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6800 states and 9167 transitions.
[2020-11-25 05:49:41,793 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:41,793 INFO  L728         BuchiCegarLoop]: Abstraction has 6800 states and 9167 transitions.
[2020-11-25 05:49:41,795 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6800 states and 9167 transitions.
[2020-11-25 05:49:41,837 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6800 to 6791.
[2020-11-25 05:49:41,837 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6791 states.
[2020-11-25 05:49:41,852 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6791 states to 6791 states and 9150 transitions.
[2020-11-25 05:49:41,852 INFO  L751         BuchiCegarLoop]: Abstraction has 6791 states and 9150 transitions.
[2020-11-25 05:49:41,852 INFO  L631         BuchiCegarLoop]: Abstraction has 6791 states and 9150 transitions.
[2020-11-25 05:49:41,852 INFO  L445         BuchiCegarLoop]: ======== Iteration 29============
[2020-11-25 05:49:41,852 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6791 states and 9150 transitions.
[2020-11-25 05:49:41,860 INFO  L131   ngComponentsAnalysis]: Automaton has 10 accepting balls. 56
[2020-11-25 05:49:41,860 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:41,860 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:41,861 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:41,861 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:41,864 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:41,864 INFO  L82        PathProgramCache]: Analyzing trace with hash -596133521, now seen corresponding path program 1 times
[2020-11-25 05:49:41,865 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:41,885 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:42,187 INFO  L134       CoverageAnalysis]: Checked inductivity of 548 backedges. 25 proven. 56 refuted. 0 times theorem prover too weak. 467 trivial. 0 not checked.
[2020-11-25 05:49:42,188 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:42,188 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [37] total 37
[2020-11-25 05:49:42,188 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:42,188 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 38 interpolants.
[2020-11-25 05:49:42,188 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=115, Invalid=1291, Unknown=0, NotChecked=0, Total=1406
[2020-11-25 05:49:42,188 INFO  L87              Difference]: Start difference. First operand 6791 states and 9150 transitions. cyclomatic complexity: 2415 Second operand 38 states.
[2020-11-25 05:49:44,608 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:44,608 INFO  L93              Difference]: Finished difference Result 6785 states and 9029 transitions.
[2020-11-25 05:49:44,608 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 36 states. 
[2020-11-25 05:49:44,608 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 6785 states and 9029 transitions.
[2020-11-25 05:49:44,630 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 36
[2020-11-25 05:49:44,655 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 6785 states to 6785 states and 9029 transitions.
[2020-11-25 05:49:44,655 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2115
[2020-11-25 05:49:44,656 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2115
[2020-11-25 05:49:44,656 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 6785 states and 9029 transitions.
[2020-11-25 05:49:44,662 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:44,662 INFO  L728         BuchiCegarLoop]: Abstraction has 6785 states and 9029 transitions.
[2020-11-25 05:49:44,664 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 6785 states and 9029 transitions.
[2020-11-25 05:49:44,703 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 6785 to 6705.
[2020-11-25 05:49:44,703 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 6705 states.
[2020-11-25 05:49:44,716 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 6705 states to 6705 states and 8707 transitions.
[2020-11-25 05:49:44,716 INFO  L751         BuchiCegarLoop]: Abstraction has 6705 states and 8707 transitions.
[2020-11-25 05:49:44,716 INFO  L631         BuchiCegarLoop]: Abstraction has 6705 states and 8707 transitions.
[2020-11-25 05:49:44,716 INFO  L445         BuchiCegarLoop]: ======== Iteration 30============
[2020-11-25 05:49:44,716 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 6705 states and 8707 transitions.
[2020-11-25 05:49:44,724 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 36
[2020-11-25 05:49:44,724 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:44,724 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:44,725 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:44,725 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND TRUE   choice == 5
[L3566]              gas := gas - 21000;
[L3567]  COND TRUE   gas >= 0
[L3568]              assume msgvalue_MSG == 0;
[L3569]  CALL        call stopTrade_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L503]               havoc __exception;
[L504]               revert := false;
[L505]   COND FALSE  !(__exception)
[L528]   CALL        call stopTrade_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1977]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L1977]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L1978]  COND FALSE  !(revert)
[L1981]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L1985]              _stopTrade_StreamProtocol[this] := true;
[L528]   RET         call stopTrade_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L529]               assume !revert && gas >= 0;
[L3569]  RET         call stopTrade_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:44,728 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:44,728 INFO  L82        PathProgramCache]: Analyzing trace with hash 355170962, now seen corresponding path program 1 times
[2020-11-25 05:49:44,729 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:44,740 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:44,828 INFO  L134       CoverageAnalysis]: Checked inductivity of 528 backedges. 117 proven. 103 refuted. 0 times theorem prover too weak. 308 trivial. 0 not checked.
[2020-11-25 05:49:44,828 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:44,828 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [10] total 10
[2020-11-25 05:49:44,829 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:44,829 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 10 interpolants.
[2020-11-25 05:49:44,829 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=18, Invalid=72, Unknown=0, NotChecked=0, Total=90
[2020-11-25 05:49:44,829 INFO  L87              Difference]: Start difference. First operand 6705 states and 8707 transitions. cyclomatic complexity: 2049 Second operand 10 states.
[2020-11-25 05:49:45,385 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:45,385 INFO  L93              Difference]: Finished difference Result 8833 states and 12344 transitions.
[2020-11-25 05:49:45,385 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 13 states. 
[2020-11-25 05:49:45,386 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8833 states and 12344 transitions.
[2020-11-25 05:49:45,417 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 58
[2020-11-25 05:49:45,457 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8833 states to 8779 states and 12272 transitions.
[2020-11-25 05:49:45,457 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2508
[2020-11-25 05:49:45,458 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2556
[2020-11-25 05:49:45,458 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8779 states and 12272 transitions.
[2020-11-25 05:49:45,467 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:45,467 INFO  L728         BuchiCegarLoop]: Abstraction has 8779 states and 12272 transitions.
[2020-11-25 05:49:45,470 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8779 states and 12272 transitions.
[2020-11-25 05:49:45,525 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8779 to 8699.
[2020-11-25 05:49:45,525 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8699 states.
[2020-11-25 05:49:45,547 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8699 states to 8699 states and 12093 transitions.
[2020-11-25 05:49:45,547 INFO  L751         BuchiCegarLoop]: Abstraction has 8699 states and 12093 transitions.
[2020-11-25 05:49:45,547 INFO  L631         BuchiCegarLoop]: Abstraction has 8699 states and 12093 transitions.
[2020-11-25 05:49:45,547 INFO  L445         BuchiCegarLoop]: ======== Iteration 31============
[2020-11-25 05:49:45,547 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8699 states and 12093 transitions.
[2020-11-25 05:49:45,557 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 58
[2020-11-25 05:49:45,557 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:45,557 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:45,558 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:45,558 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:45,560 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:45,560 INFO  L82        PathProgramCache]: Analyzing trace with hash -942026111, now seen corresponding path program 1 times
[2020-11-25 05:49:45,561 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:45,575 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:45,856 INFO  L134       CoverageAnalysis]: Checked inductivity of 157 backedges. 0 proven. 6 refuted. 0 times theorem prover too weak. 151 trivial. 0 not checked.
[2020-11-25 05:49:45,856 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:45,856 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [36] total 36
[2020-11-25 05:49:45,857 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:45,857 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 37 interpolants.
[2020-11-25 05:49:45,857 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=103, Invalid=1229, Unknown=0, NotChecked=0, Total=1332
[2020-11-25 05:49:45,857 INFO  L87              Difference]: Start difference. First operand 8699 states and 12093 transitions. cyclomatic complexity: 3441 Second operand 37 states.
[2020-11-25 05:49:48,701 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:48,701 INFO  L93              Difference]: Finished difference Result 8812 states and 12070 transitions.
[2020-11-25 05:49:48,701 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 36 states. 
[2020-11-25 05:49:48,702 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8812 states and 12070 transitions.
[2020-11-25 05:49:48,732 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:49:48,769 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8812 states to 8812 states and 12070 transitions.
[2020-11-25 05:49:48,769 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2559
[2020-11-25 05:49:48,770 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2559
[2020-11-25 05:49:48,770 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8812 states and 12070 transitions.
[2020-11-25 05:49:48,779 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:48,779 INFO  L728         BuchiCegarLoop]: Abstraction has 8812 states and 12070 transitions.
[2020-11-25 05:49:48,781 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8812 states and 12070 transitions.
[2020-11-25 05:49:48,830 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8812 to 8657.
[2020-11-25 05:49:48,831 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8657 states.
[2020-11-25 05:49:48,851 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8657 states to 8657 states and 11851 transitions.
[2020-11-25 05:49:48,851 INFO  L751         BuchiCegarLoop]: Abstraction has 8657 states and 11851 transitions.
[2020-11-25 05:49:48,852 INFO  L631         BuchiCegarLoop]: Abstraction has 8657 states and 11851 transitions.
[2020-11-25 05:49:48,852 INFO  L445         BuchiCegarLoop]: ======== Iteration 32============
[2020-11-25 05:49:48,852 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8657 states and 11851 transitions.
[2020-11-25 05:49:48,861 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:49:48,862 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:48,862 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:48,862 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:48,863 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND FALSE  !(gas >= 0)
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:48,866 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:48,866 INFO  L82        PathProgramCache]: Analyzing trace with hash -295106109, now seen corresponding path program 1 times
[2020-11-25 05:49:48,866 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:48,883 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:49,259 INFO  L134       CoverageAnalysis]: Checked inductivity of 577 backedges. 278 proven. 86 refuted. 0 times theorem prover too weak. 213 trivial. 0 not checked.
[2020-11-25 05:49:49,259 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:49,259 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [43] total 43
[2020-11-25 05:49:49,259 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:49,260 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 44 interpolants.
[2020-11-25 05:49:49,260 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=156, Invalid=1736, Unknown=0, NotChecked=0, Total=1892
[2020-11-25 05:49:49,260 INFO  L87              Difference]: Start difference. First operand 8657 states and 11851 transitions. cyclomatic complexity: 3237 Second operand 44 states.
[2020-11-25 05:49:51,363 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:51,363 INFO  L93              Difference]: Finished difference Result 8810 states and 12564 transitions.
[2020-11-25 05:49:51,363 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 37 states. 
[2020-11-25 05:49:51,363 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8810 states and 12564 transitions.
[2020-11-25 05:49:51,395 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 64
[2020-11-25 05:49:51,437 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8810 states to 8810 states and 12564 transitions.
[2020-11-25 05:49:51,437 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2553
[2020-11-25 05:49:51,438 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2553
[2020-11-25 05:49:51,438 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8810 states and 12564 transitions.
[2020-11-25 05:49:51,448 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:51,448 INFO  L728         BuchiCegarLoop]: Abstraction has 8810 states and 12564 transitions.
[2020-11-25 05:49:51,450 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8810 states and 12564 transitions.
[2020-11-25 05:49:51,507 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8810 to 8763.
[2020-11-25 05:49:51,507 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8763 states.
[2020-11-25 05:49:51,532 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8763 states to 8763 states and 12482 transitions.
[2020-11-25 05:49:51,533 INFO  L751         BuchiCegarLoop]: Abstraction has 8763 states and 12482 transitions.
[2020-11-25 05:49:51,533 INFO  L631         BuchiCegarLoop]: Abstraction has 8763 states and 12482 transitions.
[2020-11-25 05:49:51,533 INFO  L445         BuchiCegarLoop]: ======== Iteration 33============
[2020-11-25 05:49:51,533 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8763 states and 12482 transitions.
[2020-11-25 05:49:51,543 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 64
[2020-11-25 05:49:51,543 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:51,543 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:51,544 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:51,544 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:51,547 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:51,547 INFO  L82        PathProgramCache]: Analyzing trace with hash -1945524394, now seen corresponding path program 1 times
[2020-11-25 05:49:51,548 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:51,566 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:51,922 INFO  L134       CoverageAnalysis]: Checked inductivity of 577 backedges. 27 proven. 86 refuted. 0 times theorem prover too weak. 464 trivial. 0 not checked.
[2020-11-25 05:49:51,922 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:51,922 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [40] total 40
[2020-11-25 05:49:51,923 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:51,923 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 41 interpolants.
[2020-11-25 05:49:51,923 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=125, Invalid=1515, Unknown=0, NotChecked=0, Total=1640
[2020-11-25 05:49:51,923 INFO  L87              Difference]: Start difference. First operand 8763 states and 12482 transitions. cyclomatic complexity: 3771 Second operand 41 states.
[2020-11-25 05:49:53,904 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:53,904 INFO  L93              Difference]: Finished difference Result 8781 states and 12350 transitions.
[2020-11-25 05:49:53,905 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 37 states. 
[2020-11-25 05:49:53,905 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8781 states and 12350 transitions.
[2020-11-25 05:49:53,962 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:49:54,020 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8781 states to 8781 states and 12350 transitions.
[2020-11-25 05:49:54,020 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2521
[2020-11-25 05:49:54,021 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2521
[2020-11-25 05:49:54,021 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8781 states and 12350 transitions.
[2020-11-25 05:49:54,035 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:54,035 INFO  L728         BuchiCegarLoop]: Abstraction has 8781 states and 12350 transitions.
[2020-11-25 05:49:54,038 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8781 states and 12350 transitions.
[2020-11-25 05:49:54,104 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8781 to 8655.
[2020-11-25 05:49:54,104 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8655 states.
[2020-11-25 05:49:54,126 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8655 states to 8655 states and 11846 transitions.
[2020-11-25 05:49:54,126 INFO  L751         BuchiCegarLoop]: Abstraction has 8655 states and 11846 transitions.
[2020-11-25 05:49:54,126 INFO  L631         BuchiCegarLoop]: Abstraction has 8655 states and 11846 transitions.
[2020-11-25 05:49:54,126 INFO  L445         BuchiCegarLoop]: ======== Iteration 34============
[2020-11-25 05:49:54,126 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8655 states and 11846 transitions.
[2020-11-25 05:49:54,136 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:49:54,136 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:54,136 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:54,137 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:54,137 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:54,140 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:54,140 INFO  L82        PathProgramCache]: Analyzing trace with hash 102355645, now seen corresponding path program 1 times
[2020-11-25 05:49:54,140 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:54,157 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:54,592 INFO  L134       CoverageAnalysis]: Checked inductivity of 548 backedges. 294 proven. 50 refuted. 0 times theorem prover too weak. 204 trivial. 0 not checked.
[2020-11-25 05:49:54,592 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:54,592 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [42] total 42
[2020-11-25 05:49:54,593 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:54,593 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 43 interpolants.
[2020-11-25 05:49:54,593 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=143, Invalid=1663, Unknown=0, NotChecked=0, Total=1806
[2020-11-25 05:49:54,593 INFO  L87              Difference]: Start difference. First operand 8655 states and 11846 transitions. cyclomatic complexity: 3234 Second operand 43 states.
[2020-11-25 05:49:56,734 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:56,734 INFO  L93              Difference]: Finished difference Result 8874 states and 12976 transitions.
[2020-11-25 05:49:56,734 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 40 states. 
[2020-11-25 05:49:56,734 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8874 states and 12976 transitions.
[2020-11-25 05:49:56,772 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 64
[2020-11-25 05:49:56,820 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8874 states to 8874 states and 12976 transitions.
[2020-11-25 05:49:56,820 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2553
[2020-11-25 05:49:56,821 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2553
[2020-11-25 05:49:56,821 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8874 states and 12976 transitions.
[2020-11-25 05:49:56,831 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:56,831 INFO  L728         BuchiCegarLoop]: Abstraction has 8874 states and 12976 transitions.
[2020-11-25 05:49:56,834 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8874 states and 12976 transitions.
[2020-11-25 05:49:56,896 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8874 to 8835.
[2020-11-25 05:49:56,896 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8835 states.
[2020-11-25 05:49:56,924 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8835 states to 8835 states and 12910 transitions.
[2020-11-25 05:49:56,924 INFO  L751         BuchiCegarLoop]: Abstraction has 8835 states and 12910 transitions.
[2020-11-25 05:49:56,924 INFO  L631         BuchiCegarLoop]: Abstraction has 8835 states and 12910 transitions.
[2020-11-25 05:49:56,924 INFO  L445         BuchiCegarLoop]: ======== Iteration 35============
[2020-11-25 05:49:56,924 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8835 states and 12910 transitions.
[2020-11-25 05:49:56,935 INFO  L131   ngComponentsAnalysis]: Automaton has 6 accepting balls. 64
[2020-11-25 05:49:56,935 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:49:56,935 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:49:56,936 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:49:56,936 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:49:56,939 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:49:56,939 INFO  L82        PathProgramCache]: Analyzing trace with hash -1748742704, now seen corresponding path program 1 times
[2020-11-25 05:49:56,939 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:49:56,962 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:49:57,354 INFO  L134       CoverageAnalysis]: Checked inductivity of 548 backedges. 24 proven. 50 refuted. 0 times theorem prover too weak. 474 trivial. 0 not checked.
[2020-11-25 05:49:57,354 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:49:57,354 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [42] total 42
[2020-11-25 05:49:57,355 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:49:57,355 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 43 interpolants.
[2020-11-25 05:49:57,355 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=138, Invalid=1668, Unknown=0, NotChecked=0, Total=1806
[2020-11-25 05:49:57,356 INFO  L87              Difference]: Start difference. First operand 8835 states and 12910 transitions. cyclomatic complexity: 4133 Second operand 43 states.
[2020-11-25 05:49:59,835 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:49:59,835 INFO  L93              Difference]: Finished difference Result 8845 states and 12762 transitions.
[2020-11-25 05:49:59,835 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 40 states. 
[2020-11-25 05:49:59,835 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8845 states and 12762 transitions.
[2020-11-25 05:49:59,869 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:49:59,911 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8845 states to 8845 states and 12762 transitions.
[2020-11-25 05:49:59,912 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2521
[2020-11-25 05:49:59,913 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2521
[2020-11-25 05:49:59,913 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8845 states and 12762 transitions.
[2020-11-25 05:49:59,922 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:49:59,922 INFO  L728         BuchiCegarLoop]: Abstraction has 8845 states and 12762 transitions.
[2020-11-25 05:49:59,925 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8845 states and 12762 transitions.
[2020-11-25 05:49:59,983 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8845 to 8787.
[2020-11-25 05:49:59,983 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8787 states.
[2020-11-25 05:50:00,008 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8787 states to 8787 states and 12684 transitions.
[2020-11-25 05:50:00,008 INFO  L751         BuchiCegarLoop]: Abstraction has 8787 states and 12684 transitions.
[2020-11-25 05:50:00,009 INFO  L631         BuchiCegarLoop]: Abstraction has 8787 states and 12684 transitions.
[2020-11-25 05:50:00,009 INFO  L445         BuchiCegarLoop]: ======== Iteration 36============
[2020-11-25 05:50:00,009 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8787 states and 12684 transitions.
[2020-11-25 05:50:00,019 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:50:00,019 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:50:00,019 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:50:00,019 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:50:00,020 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:50:00,022 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:50:00,023 INFO  L82        PathProgramCache]: Analyzing trace with hash -197409155, now seen corresponding path program 1 times
[2020-11-25 05:50:00,023 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:50:00,039 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:50:00,408 INFO  L134       CoverageAnalysis]: Checked inductivity of 347 backedges. 0 proven. 57 refuted. 0 times theorem prover too weak. 290 trivial. 0 not checked.
[2020-11-25 05:50:00,409 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:50:00,409 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [41] total 41
[2020-11-25 05:50:00,409 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:50:00,409 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 42 interpolants.
[2020-11-25 05:50:00,409 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=130, Invalid=1592, Unknown=0, NotChecked=0, Total=1722
[2020-11-25 05:50:00,409 INFO  L87              Difference]: Start difference. First operand 8787 states and 12684 transitions. cyclomatic complexity: 3952 Second operand 42 states.
[2020-11-25 05:50:05,654 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:50:05,654 INFO  L93              Difference]: Finished difference Result 9785 states and 13987 transitions.
[2020-11-25 05:50:05,654 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 62 states. 
[2020-11-25 05:50:05,654 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 9785 states and 13987 transitions.
[2020-11-25 05:50:05,694 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 58
[2020-11-25 05:50:05,741 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 9785 states to 9785 states and 13987 transitions.
[2020-11-25 05:50:05,741 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2977
[2020-11-25 05:50:05,743 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2977
[2020-11-25 05:50:05,743 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 9785 states and 13987 transitions.
[2020-11-25 05:50:05,753 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:50:05,753 INFO  L728         BuchiCegarLoop]: Abstraction has 9785 states and 13987 transitions.
[2020-11-25 05:50:05,756 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 9785 states and 13987 transitions.
[2020-11-25 05:50:05,815 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 9785 to 8843.
[2020-11-25 05:50:05,816 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8843 states.
[2020-11-25 05:50:05,843 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8843 states to 8843 states and 13013 transitions.
[2020-11-25 05:50:05,843 INFO  L751         BuchiCegarLoop]: Abstraction has 8843 states and 13013 transitions.
[2020-11-25 05:50:05,843 INFO  L631         BuchiCegarLoop]: Abstraction has 8843 states and 13013 transitions.
[2020-11-25 05:50:05,844 INFO  L445         BuchiCegarLoop]: ======== Iteration 37============
[2020-11-25 05:50:05,844 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8843 states and 13013 transitions.
[2020-11-25 05:50:05,854 INFO  L131   ngComponentsAnalysis]: Automaton has 7 accepting balls. 58
[2020-11-25 05:50:05,854 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:50:05,854 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:50:05,855 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:50:05,855 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:50:05,857 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:50:05,857 INFO  L82        PathProgramCache]: Analyzing trace with hash 1597493648, now seen corresponding path program 1 times
[2020-11-25 05:50:05,858 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:50:05,877 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:50:06,297 INFO  L134       CoverageAnalysis]: Checked inductivity of 347 backedges. 0 proven. 55 refuted. 0 times theorem prover too weak. 292 trivial. 0 not checked.
[2020-11-25 05:50:06,297 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:50:06,297 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [41] total 41
[2020-11-25 05:50:06,298 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:50:06,298 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 42 interpolants.
[2020-11-25 05:50:06,298 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=127, Invalid=1595, Unknown=0, NotChecked=0, Total=1722
[2020-11-25 05:50:06,298 INFO  L87              Difference]: Start difference. First operand 8843 states and 13013 transitions. cyclomatic complexity: 4233 Second operand 42 states.
[2020-11-25 05:50:09,429 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:50:09,429 INFO  L93              Difference]: Finished difference Result 8884 states and 12951 transitions.
[2020-11-25 05:50:09,429 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 38 states. 
[2020-11-25 05:50:09,429 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8884 states and 12951 transitions.
[2020-11-25 05:50:09,464 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:50:09,507 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8884 states to 8884 states and 12951 transitions.
[2020-11-25 05:50:09,507 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2533
[2020-11-25 05:50:09,508 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2533
[2020-11-25 05:50:09,508 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8884 states and 12951 transitions.
[2020-11-25 05:50:09,519 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:50:09,519 INFO  L728         BuchiCegarLoop]: Abstraction has 8884 states and 12951 transitions.
[2020-11-25 05:50:09,521 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8884 states and 12951 transitions.
[2020-11-25 05:50:09,580 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8884 to 8813.
[2020-11-25 05:50:09,580 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8813 states.
[2020-11-25 05:50:09,608 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8813 states to 8813 states and 12829 transitions.
[2020-11-25 05:50:09,608 INFO  L751         BuchiCegarLoop]: Abstraction has 8813 states and 12829 transitions.
[2020-11-25 05:50:09,608 INFO  L631         BuchiCegarLoop]: Abstraction has 8813 states and 12829 transitions.
[2020-11-25 05:50:09,608 INFO  L445         BuchiCegarLoop]: ======== Iteration 38============
[2020-11-25 05:50:09,608 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8813 states and 12829 transitions.
[2020-11-25 05:50:09,618 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:50:09,618 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:50:09,618 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:50:09,619 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:50:09,620 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND TRUE   __exception
[L451]               __tmp__Balance := Balance;
[L452]               __tmp__DType := DType;
[L453]               __tmp__Alloc := Alloc;
[L454]               __tmp__balance_ADDR := balance_ADDR;
[L455]               __tmp__M_Ref_int := M_Ref_int;
[L456]               __tmp__sum_balances0 := sum_balances0;
[L457]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L458]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L459]               __tmp__sum_allowed1 := sum_allowed1;
[L460]               __tmp__Length := Length;
[L461]               __tmp__now := now;
[L462]               __tmp__owner_Owned := owner_Owned;
[L463]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L464]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L465]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L466]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L467]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L468]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L469]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L470]   CALL        call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L1940]              __var_3 := null;
[L1941]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1683]  COND TRUE   !(b_s45 <= a_s45)
[L1684]              revert := true;
[L1941]  RET         call __var_2 := sub~uint256~uint256_SafeMath__fail(this, this, 0, __tmp___totalSupply_StreamProtocol[this], __tmp__balances_StreamProtocol[this][null]);
[L1942]  COND TRUE   revert
[L470]   RET         call __ret_0_ := totalSupply_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG);
[L471]               assume revert || gas < 0;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:50:09,623 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:50:09,623 INFO  L82        PathProgramCache]: Analyzing trace with hash -10057394, now seen corresponding path program 1 times
[2020-11-25 05:50:09,623 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:50:09,643 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:50:10,180 INFO  L134       CoverageAnalysis]: Checked inductivity of 864 backedges. 407 proven. 117 refuted. 0 times theorem prover too weak. 340 trivial. 0 not checked.
[2020-11-25 05:50:10,180 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:50:10,180 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [48] total 48
[2020-11-25 05:50:10,180 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:50:10,180 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 49 interpolants.
[2020-11-25 05:50:10,181 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=180, Invalid=2172, Unknown=0, NotChecked=0, Total=2352
[2020-11-25 05:50:10,181 INFO  L87              Difference]: Start difference. First operand 8813 states and 12829 transitions. cyclomatic complexity: 4075 Second operand 49 states.
[2020-11-25 05:50:12,491 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:50:12,491 INFO  L93              Difference]: Finished difference Result 8860 states and 12841 transitions.
[2020-11-25 05:50:12,491 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 41 states. 
[2020-11-25 05:50:12,491 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 8860 states and 12841 transitions.
[2020-11-25 05:50:12,527 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:50:12,572 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 8860 states to 8800 states and 12737 transitions.
[2020-11-25 05:50:12,572 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 2483
[2020-11-25 05:50:12,573 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 2483
[2020-11-25 05:50:12,573 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 8800 states and 12737 transitions.
[2020-11-25 05:50:12,583 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:50:12,583 INFO  L728         BuchiCegarLoop]: Abstraction has 8800 states and 12737 transitions.
[2020-11-25 05:50:12,585 INFO  L82        GeneralOperation]: Start minimizeSevpa. Operand 8800 states and 12737 transitions.
[2020-11-25 05:50:12,642 INFO  L88        GeneralOperation]: Finished minimizeSevpa. Reduced states from 8800 to 8753.
[2020-11-25 05:50:12,642 INFO  L82        GeneralOperation]: Start removeUnreachable. Operand 8753 states.
[2020-11-25 05:50:12,669 INFO  L88        GeneralOperation]: Finished removeUnreachable. Reduced from 8753 states to 8753 states and 12677 transitions.
[2020-11-25 05:50:12,669 INFO  L751         BuchiCegarLoop]: Abstraction has 8753 states and 12677 transitions.
[2020-11-25 05:50:12,669 INFO  L631         BuchiCegarLoop]: Abstraction has 8753 states and 12677 transitions.
[2020-11-25 05:50:12,669 INFO  L445         BuchiCegarLoop]: ======== Iteration 39============
[2020-11-25 05:50:12,669 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 8753 states and 12677 transitions.
[2020-11-25 05:50:12,679 INFO  L131   ngComponentsAnalysis]: Automaton has 3 accepting balls. 32
[2020-11-25 05:50:12,679 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is false
[2020-11-25 05:50:12,679 INFO  L119           BuchiIsEmpty]: Starting construction of run
[2020-11-25 05:50:12,680 INFO  L889         BuchiCegarLoop]: Counterexample stem histogram [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 3, 3, 3, 3, 3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
[2020-11-25 05:50:12,680 INFO  L890         BuchiCegarLoop]: Counterexample loop histogram [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Stem:
[L2]                 success_totalSupply_StreamProtocol0 := false;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]     CALL        call main();
[L3606]              assume null == 0;
[L3607]  CALL        call this := FreshRefGenerator__success();
[L1625]              havoc newRef;
[L1626]              assume Alloc[newRef] == false;
[L1627]              Alloc[newRef] := true;
[L1628]              assume newRef != null;
[L3607]  RET         call this := FreshRefGenerator__success();
[L3608]              assume now >= 0;
[L3609]              assume DType[this] == StreamProtocol;
[L3610]              assume msgvalue_MSG == 0;
[L3611]              gas := gas - 53000;
[L3612]  CALL        call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L394]               havoc __exception;
[L395]               revert := false;
[L396]   COND FALSE  !(__exception)
[L419]   CALL        call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1922]  CALL        call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1761]  CALL        call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1746]              assume msgsender_MSG != null;
[L1747]              Balance[this] := 0;
[L1761]  RET         call ERC20Interface_ERC20Interface_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1762]  COND FALSE  !(revert)
[L1922]  RET         call ERC20Interface_ERC20Interface__success(this, msgsender_MSG, msgvalue_MSG);
[L1923]  COND FALSE  !(revert)
[L1926]  CALL        call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1829]  CALL        call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1812]              assume msgsender_MSG != null;
[L1813]              Balance[this] := 0;
[L1814]              owner_Owned[this] := null;
[L1816]              owner_Owned[this] := msgsender_MSG;
[L1829]  RET         call Owned_Owned_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1830]  COND FALSE  !(revert)
[L1926]  RET         call Owned_Owned__success(this, msgsender_MSG, msgvalue_MSG);
[L1927]  COND FALSE  !(revert)
[L1930]  CALL        call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1878]              assume msgsender_MSG != null;
[L1879]              Balance[this] := 0;
[L1880]              symbol_StreamProtocol[this] := 1491346165;
[L1881]              name_StreamProtocol[this] := 1491346165;
[L1882]              decimals_StreamProtocol[this] := 0;
[L1883]              _totalSupply_StreamProtocol[this] := 0;
[L1884]              _stopTrade_StreamProtocol[this] := false;
[L1885]              balances_StreamProtocol[this] := zeroRefintArr();
[L1886]              sum_balances0[this] := 0;
[L1887]              allowed_StreamProtocol[this] := zeroRefRefintArr();
[L1888]              sum_allowed1[this] := 0;
[L1890]              symbol_StreamProtocol[this] := 1357906882;
[L1891]              name_StreamProtocol[this] := -1605590943;
[L1892]              decimals_StreamProtocol[this] := 18;
[L1893]              __var_1 := decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1894]              _totalSupply_StreamProtocol[this] := 2000000000 * (nonlinearPow(10, decimals_StreamProtocol[this] % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1895]              _stopTrade_StreamProtocol[this] := false;
[L1896]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][owner_Owned[this]];
[L1897]              balances_StreamProtocol[this][owner_Owned[this]] := _totalSupply_StreamProtocol[this];
[L1898]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][owner_Owned[this]];
[L1899]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L1930]  RET         call StreamProtocol_StreamProtocol_NoBaseCtor__success(this, msgsender_MSG, msgvalue_MSG);
[L1931]  COND FALSE  !(revert)
[L419]   RET         call StreamProtocol_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L420]               assume !revert && gas >= 0;
[L3612]  RET         call StreamProtocol_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3613]              assume !revert && gas >= 0;
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND TRUE   __exception
[L671]               __tmp__Balance := Balance;
[L672]               __tmp__DType := DType;
[L673]               __tmp__Alloc := Alloc;
[L674]               __tmp__balance_ADDR := balance_ADDR;
[L675]               __tmp__M_Ref_int := M_Ref_int;
[L676]               __tmp__sum_balances0 := sum_balances0;
[L677]               __tmp__alloc_allowed_StreamProtocol_lvl0 := alloc_allowed_StreamProtocol_lvl0;
[L678]               __tmp__M_Ref_Ref := M_Ref_Ref;
[L679]               __tmp__sum_allowed1 := sum_allowed1;
[L680]               __tmp__Length := Length;
[L681]               __tmp__now := now;
[L682]               __tmp__owner_Owned := owner_Owned;
[L683]               __tmp__symbol_StreamProtocol := symbol_StreamProtocol;
[L684]               __tmp__name_StreamProtocol := name_StreamProtocol;
[L685]               __tmp__decimals_StreamProtocol := decimals_StreamProtocol;
[L686]               __tmp___totalSupply_StreamProtocol := _totalSupply_StreamProtocol;
[L687]               __tmp___stopTrade_StreamProtocol := _stopTrade_StreamProtocol;
[L688]               __tmp__balances_StreamProtocol := balances_StreamProtocol;
[L689]               __tmp__allowed_StreamProtocol := allowed_StreamProtocol;
[L690]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2031]  COND FALSE  !(!(__tmp___stopTrade_StreamProtocol[this] != true))
[L2035]              __var_4 := null;
[L2036]  COND TRUE   !(to_s385 > null)
[L2037]              revert := true;
[L690]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__fail(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L691]               assume revert || gas < 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND TRUE   choice == 12
[L3521]              gas := gas - 21000;
[L3522]  COND TRUE   gas >= 0
[L3523]              assume tokens_s385 >= 0 && tokens_s385 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3524]              assume msgvalue_MSG == 0;
[L3525]  CALL        call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L668]               havoc __exception;
[L669]               revert := false;
[L670]   COND FALSE  !(__exception)
[L693]   CALL        call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L693]   RET         call success_s385 := transfer~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L694]               assume !revert && gas >= 0;
[L3525]  RET         call success_s385 := transfer~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, to_s385, tokens_s385);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND FALSE  !(choice == 2)
[L3591]  COND TRUE   choice == 1
[L3592]              gas := gas - 21000;
[L3593]  COND TRUE   gas >= 0
[L3594]              assume _value_s658 >= 0 && _value_s658 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3595]              assume msgvalue_MSG == 0;
[L3596]  CALL        call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1008]              havoc __exception;
[L1009]              revert := false;
[L1010]  COND FALSE  !(__exception)
[L1033]  CALL        call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L2377]  COND FALSE  !(!(_value_s658 <= balances_StreamProtocol[this][msgsender_MSG]))
[L2381]              burner_s658 := msgsender_MSG;
[L2382]  CALL        call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2382]  RET         call __var_18 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][burner_s658], _value_s658);
[L2383]  COND FALSE  !(revert)
[L2386]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][burner_s658];
[L2387]              balances_StreamProtocol[this][burner_s658] := __var_18;
[L2388]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][burner_s658];
[L2389]  CALL        call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2389]  RET         call __var_19 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], _value_s658);
[L2390]  COND FALSE  !(revert)
[L2393]              _totalSupply_StreamProtocol[this] := __var_19;
[L2394]              assert { :EventEmitted "Burn_StreamProtocol" } true;
[L1033]  RET         call burn~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L1034]              assume !revert && gas >= 0;
[L3596]  RET         call burn~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, _value_s658);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND TRUE   choice == 10
[L3535]              gas := gas - 21000;
[L3536]  COND TRUE   gas >= 0
[L3537]              assume tokens_s510 >= 0 && tokens_s510 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3538]              assume msgvalue_MSG == 0;
[L3539]  CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L782]               havoc __exception;
[L783]               revert := false;
[L784]   COND FALSE  !(__exception)
[L807]   CALL        call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L2173]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2177]              __var_7 := null;
[L2178]  COND FALSE  !(!(from_s510 > null))
[L2182]              __var_8 := null;
[L2183]  COND FALSE  !(!(to_s510 > null))
[L2187]  CALL        call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2187]  RET         call __var_9 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][from_s510], tokens_s510);
[L2188]  COND FALSE  !(revert)
[L2191]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][from_s510];
[L2192]              balances_StreamProtocol[this][from_s510] := __var_9;
[L2193]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][from_s510];
[L2194]  COND FALSE  !(from_s510 != to_s510 && from_s510 != msgsender_MSG)
[L2203]  CALL        call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2203]  RET         call __var_11 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s510], tokens_s510);
[L2204]  COND FALSE  !(revert)
[L2207]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s510];
[L2208]              balances_StreamProtocol[this][to_s510] := __var_11;
[L2209]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s510];
[L2210]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2211]              success_s510 := true;
[L807]   RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L808]               assume !revert && gas >= 0;
[L3539]  RET         call success_s510 := transferFrom~address~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, from_s510, to_s510, tokens_s510);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND FALSE  !(choice == 15)
[L3508]  COND FALSE  !(choice == 14)
[L3514]  COND FALSE  !(choice == 13)
[L3520]  COND FALSE  !(choice == 12)
[L3527]  COND FALSE  !(choice == 11)
[L3534]  COND FALSE  !(choice == 10)
[L3541]  COND FALSE  !(choice == 9)
[L3547]  COND FALSE  !(choice == 8)
[L3553]  COND FALSE  !(choice == 7)
[L3559]  COND FALSE  !(choice == 6)
[L3565]  COND FALSE  !(choice == 5)
[L3571]  COND FALSE  !(choice == 4)
[L3577]  COND FALSE  !(choice == 3)
[L3584]  COND TRUE   choice == 2
[L3585]              gas := gas - 21000;
[L3586]  COND TRUE   gas >= 0
[L3587]              assume tokens_s609 >= 0 && tokens_s609 < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L3588]              assume msgvalue_MSG == 0;
[L3589]  CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L951]               havoc __exception;
[L952]               revert := false;
[L953]   COND FALSE  !(__exception)
[L976]   CALL        call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L2328]  CALL        call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L3149]  COND FALSE  !(!(msgsender_MSG == owner_Owned[this]))
[L2328]  RET         call onlyOwner_pre__success(this, msgsender_MSG, msgvalue_MSG);
[L2329]  COND FALSE  !(revert)
[L2332]              assume DType[tokenAddress_s609] == ERC20Interface || DType[tokenAddress_s609] == StreamProtocol;
[L2333]              __var_16 := tokenAddress_s609;
[L2334]  COND TRUE   DType[__var_16] == StreamProtocol
[L2335]  CALL        call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2063]  COND FALSE  !(!(_stopTrade_StreamProtocol[this] != true))
[L2067]              __var_4 := null;
[L2068]  COND FALSE  !(!(to_s385 > null))
[L2072]  CALL        call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2072]  RET         call __var_5 := sub~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][msgsender_MSG], tokens_s385);
[L2073]  COND FALSE  !(revert)
[L2076]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][msgsender_MSG];
[L2077]              balances_StreamProtocol[this][msgsender_MSG] := __var_5;
[L2078]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][msgsender_MSG];
[L2079]  CALL        call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L1674]              c_s23 := (a_s23 + b_s23) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1675]  COND FALSE  !(!(c_s23 >= a_s23))
[L2079]  RET         call __var_6 := add~uint256~uint256_SafeMath__success(this, this, 0, balances_StreamProtocol[this][to_s385], tokens_s385);
[L2080]  COND FALSE  !(revert)
[L2083]              sum_balances0[this] := sum_balances0[this] - balances_StreamProtocol[this][to_s385];
[L2084]              balances_StreamProtocol[this][to_s385] := __var_6;
[L2085]              sum_balances0[this] := sum_balances0[this] + balances_StreamProtocol[this][to_s385];
[L2086]              assert { :EventEmitted "Transfer_StreamProtocol" } true;
[L2087]              success_s385 := true;
[L2335]  RET         call __var_15 := transfer~address~uint256_StreamProtocol__success(__var_16, this, __var_17, owner_Owned[this], tokens_s609);
[L2336]  COND FALSE  !(revert)
[L2344]              success_s609 := __var_15;
[L976]   RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L977]               assume !revert && gas >= 0;
[L3589]  RET         call success_s609 := transferAnyERC20Token~address~uint256_StreamProtocol(this, msgsender_MSG, msgvalue_MSG, tokenAddress_s609, tokens_s609);
[L3616]  RET         call CorralChoice_StreamProtocol(this);
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

Loop:
[L3616]  CALL        call CorralChoice_StreamProtocol(this);
[L3458]              havoc msgsender_MSG;
[L3459]              havoc msgvalue_MSG;
[L3460]              havoc choice;
[L3461]              havoc __ret_0_totalSupply;
[L3462]              havoc tokenOwner_s328;
[L3463]              havoc balance_s328;
[L3464]              havoc tokenOwner_s532;
[L3465]              havoc spender_s532;
[L3466]              havoc remaining_s532;
[L3467]              havoc to_s385;
[L3468]              havoc tokens_s385;
[L3469]              havoc success_s385;
[L3470]              havoc spender_s419;
[L3471]              havoc tokens_s419;
[L3472]              havoc success_s419;
[L3473]              havoc from_s510;
[L3474]              havoc to_s510;
[L3475]              havoc tokens_s510;
[L3476]              havoc success_s510;
[L3477]              havoc __ret_0_owner;
[L3478]              havoc __ret_0_symbol;
[L3479]              havoc __ret_0_name;
[L3480]              havoc __ret_0_decimals;
[L3481]              havoc spender_s582;
[L3482]              havoc tokens_s582;
[L3483]              havoc data_s582;
[L3484]              havoc success_s582;
[L3485]              havoc tokenAddress_s609;
[L3486]              havoc tokens_s609;
[L3487]              havoc success_s609;
[L3488]              havoc _value_s658;
[L3489]              havoc tmpNow;
[L3490]              havoc gas;
[L3491]              assume gas > 4000000 && gas <= 8000000;
[L3492]              tmpNow := now;
[L3493]              havoc now;
[L3494]              assume now > tmpNow;
[L3495]              assume msgsender_MSG != null;
[L3496]              assume DType[msgsender_MSG] != SafeMath;
[L3497]              assume DType[msgsender_MSG] != ERC20Interface;
[L3498]              assume DType[msgsender_MSG] != ApproveAndCallFallBack;
[L3499]              assume DType[msgsender_MSG] != Owned;
[L3500]              assume DType[msgsender_MSG] != StreamProtocol;
[L3501]              Alloc[msgsender_MSG] := true;
[L3502]  COND TRUE   choice == 15
[L3503]              gas := gas - 21000;
[L3504]  COND TRUE   gas >= 0
[L3505]              assume msgvalue_MSG == 0;
[L3506]  CALL        call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume _totalSupply_StreamProtocol[this] >= 0 && _totalSupply_StreamProtocol[this] < 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L2]                 call_totalSupply_StreamProtocol0 := true;
[L2]                 call_totalSupply_StreamProtocol0 := false;
[L2]                 revert := revert_hold;
[L448]               havoc __exception;
[L449]               revert := false;
[L450]   COND FALSE  !(__exception)
[L473]   CALL        call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L1953]              __var_3 := null;
[L1954]  CALL        call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1692]  COND FALSE  !(!(b_s45 <= a_s45))
[L1696]              c_s45 := (a_s45 - b_s45) % 115792089237316195423570985008687907853269984665640564039457584007913129639936;
[L1954]  RET         call __var_2 := sub~uint256~uint256_SafeMath__success(this, this, 0, _totalSupply_StreamProtocol[this], balances_StreamProtocol[this][null]);
[L1955]  COND FALSE  !(revert)
[L1958]              __ret_0_ := __var_2;
[L473]   RET         call __ret_0_ := totalSupply_StreamProtocol__success(this, msgsender_MSG, msgvalue_MSG);
[L474]               assume !revert && gas >= 0;
[L2]                 revert_hold := revert;
[L2]                 revert := false;
[L2]                 assume !((((((((__ret_0_ == _totalSupply_StreamProtocol[this] && _totalSupply_StreamProtocol[this] == old(_totalSupply_StreamProtocol[this])) && balances_StreamProtocol[this] == old(balances_StreamProtocol[this])) && allowed_StreamProtocol[this] == old(allowed_StreamProtocol[this])) && symbol_StreamProtocol[this] == old(symbol_StreamProtocol[this])) && name_StreamProtocol[this] == old(name_StreamProtocol[this])) && decimals_StreamProtocol[this] == old(decimals_StreamProtocol[this])) && _stopTrade_StreamProtocol[this] == old(_stopTrade_StreamProtocol[this])) && owner_Owned[this] == old(owner_Owned[this]));
[L2]                 revert := revert_hold;
[L3506]  RET         call __ret_0_totalSupply := totalSupply_StreamProtocol(this, msgsender_MSG, msgvalue_MSG);
[L3616]  RET         call CorralChoice_StreamProtocol(this);

[2020-11-25 05:50:12,683 INFO  L144       PredicateUnifier]: Initialized classic predicate unifier
[2020-11-25 05:50:12,683 INFO  L82        PathProgramCache]: Analyzing trace with hash 305030689, now seen corresponding path program 1 times
[2020-11-25 05:50:12,684 INFO  L69    tionRefinementEngine]: Using refinement strategy FixedRefinementStrategy
[2020-11-25 05:50:12,719 INFO  L140    AnnotateAndAsserter]: Conjunction of SSA is unsat
[2020-11-25 05:50:13,220 INFO  L134       CoverageAnalysis]: Checked inductivity of 864 backedges. 27 proven. 117 refuted. 0 times theorem prover too weak. 720 trivial. 0 not checked.
[2020-11-25 05:50:13,221 INFO  L312   seRefinementStrategy]: Constructing automaton from 0 perfect and 1 imperfect interpolant sequences.
[2020-11-25 05:50:13,221 INFO  L327   seRefinementStrategy]: Number of different interpolants: perfect sequences [] imperfect sequences [44] total 44
[2020-11-25 05:50:13,221 INFO  L996   eck$LassoCheckResult]: stem already infeasible
[2020-11-25 05:50:13,221 INFO  L142   InterpolantAutomaton]: Constructing interpolant automaton starting with 45 interpolants.
[2020-11-25 05:50:13,221 INFO  L144   InterpolantAutomaton]: CoverageRelationStatistics Valid=144, Invalid=1836, Unknown=0, NotChecked=0, Total=1980
[2020-11-25 05:50:13,222 INFO  L87              Difference]: Start difference. First operand 8753 states and 12677 transitions. cyclomatic complexity: 3983 Second operand 45 states.
[2020-11-25 05:50:14,459 INFO  L144             Difference]: Subtrahend was deterministic. Have not used determinization.
[2020-11-25 05:50:14,460 INFO  L93              Difference]: Finished difference Result 4922 states and 7928 transitions.
[2020-11-25 05:50:14,460 INFO  L142   InterpolantAutomaton]: Switched to read-only mode: deterministic interpolant automaton has 41 states. 
[2020-11-25 05:50:14,460 INFO  L82        GeneralOperation]: Start removeNonLiveStates. Operand 4922 states and 7928 transitions.
[2020-11-25 05:50:14,484 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-11-25 05:50:14,484 INFO  L88        GeneralOperation]: Finished removeNonLiveStates. Reduced from 4922 states to 0 states and 0 transitions.
[2020-11-25 05:50:14,484 INFO  L87         BuchiClosureNwa]: Accepting states before buchiClosure: 0
[2020-11-25 05:50:14,484 INFO  L106        BuchiClosureNwa]: Accepting states after buchiClosure: 0
[2020-11-25 05:50:14,484 INFO  L73         IsDeterministic]: Start isDeterministic. Operand 0 states and 0 transitions.
[2020-11-25 05:50:14,484 INFO  L80         IsDeterministic]: Finished isDeterministic. Operand is deterministic.
[2020-11-25 05:50:14,484 INFO  L728         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-11-25 05:50:14,484 INFO  L751         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-11-25 05:50:14,484 INFO  L631         BuchiCegarLoop]: Abstraction has 0 states and 0 transitions.
[2020-11-25 05:50:14,484 INFO  L445         BuchiCegarLoop]: ======== Iteration 40============
[2020-11-25 05:50:14,484 INFO  L72            BuchiIsEmpty]: Start buchiIsEmpty. Operand 0 states and 0 transitions.
[2020-11-25 05:50:14,485 INFO  L131   ngComponentsAnalysis]: Automaton has 0 accepting balls. 0
[2020-11-25 05:50:14,485 INFO  L87            BuchiIsEmpty]: Finished buchiIsEmpty Result is true
[2020-11-25 05:50:14,488 INFO  L202        PluginConnector]: Adding new model LTL+Program Product de.uni_freiburg.informatik.ultimate.plugins.generator.buchiautomizer CFG 25.11 05:50:14 BasicIcfg
[2020-11-25 05:50:14,488 INFO  L132        PluginConnector]: ------------------------ END BuchiAutomizer----------------------------
[2020-11-25 05:50:14,488 INFO  L168              Benchmark]: Toolchain (without parser) took 99337.25 ms. Allocated memory was 1.0 GB in the beginning and 4.7 GB in the end (delta: 3.7 GB). Free memory was 940.6 MB in the beginning and 1.3 GB in the end (delta: -345.7 MB). Peak memory consumption was 3.4 GB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,488 INFO  L168              Benchmark]: Boogie PL CUP Parser took 0.16 ms. Allocated memory is still 1.0 GB. Free memory is still 951.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,489 INFO  L168              Benchmark]: Boogie Preprocessor took 101.09 ms. Allocated memory is still 1.0 GB. Free memory was 935.2 MB in the beginning and 929.8 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,489 INFO  L168              Benchmark]: UtopiaSpecLang took 58.72 ms. Allocated memory is still 1.0 GB. Free memory was 929.8 MB in the beginning and 924.5 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,489 INFO  L168              Benchmark]: Boogie Printer took 13.88 ms. Allocated memory is still 1.0 GB. Free memory was 924.5 MB in the beginning and 919.1 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,489 INFO  L168              Benchmark]: RCFGBuilder took 744.92 ms. Allocated memory is still 1.0 GB. Free memory was 919.1 MB in the beginning and 822.3 MB in the end (delta: 96.8 MB). Peak memory consumption was 96.8 MB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,490 INFO  L168              Benchmark]: UtopiaLTL2Aut took 48.22 ms. Allocated memory is still 1.0 GB. Free memory was 822.3 MB in the beginning and 818.7 MB in the end (delta: 3.6 MB). Peak memory consumption was 3.6 MB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,490 INFO  L168              Benchmark]: BÃ¼chi Program Product took 1344.09 ms. Allocated memory was 1.0 GB in the beginning and 1.2 GB in the end (delta: 206.6 MB). Free memory was 818.7 MB in the beginning and 1.1 GB in the end (delta: -314.1 MB). Peak memory consumption was 197.4 MB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,490 INFO  L168              Benchmark]: BlockEncodingV2 took 106.95 ms. Allocated memory is still 1.2 GB. Free memory was 1.1 GB in the beginning and 1.1 GB in the end (delta: 57.4 MB). Peak memory consumption was 57.4 MB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,491 INFO  L168              Benchmark]: BuchiAutomizer took 96916.35 ms. Allocated memory was 1.2 GB in the beginning and 4.7 GB in the end (delta: 3.5 GB). Free memory was 1.1 GB in the beginning and 1.3 GB in the end (delta: -210.8 MB). Peak memory consumption was 3.3 GB. Max. memory is 15.3 GB.
[2020-11-25 05:50:14,493 INFO  L337   ainManager$Toolchain]: #######################  End [Toolchain 1] #######################
 --- Results ---
 * Results from de.uni_freiburg.informatik.ultimate.plugins.blockencoding:
  - StatisticsResult: Initial Icfg
    3092 locations, 5270 edges
  - StatisticsResult: Encoded RCFG
    3052 locations, 5170 edges
 * Results from de.uni_freiburg.informatik.ultimate.core:
  - StatisticsResult: Toolchain Benchmarks
    Benchmark results are:
 * Boogie PL CUP Parser took 0.16 ms. Allocated memory is still 1.0 GB. Free memory is still 951.3 MB. There was no memory consumed. Max. memory is 15.3 GB.
 * Boogie Preprocessor took 101.09 ms. Allocated memory is still 1.0 GB. Free memory was 935.2 MB in the beginning and 929.8 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * UtopiaSpecLang took 58.72 ms. Allocated memory is still 1.0 GB. Free memory was 929.8 MB in the beginning and 924.5 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * Boogie Printer took 13.88 ms. Allocated memory is still 1.0 GB. Free memory was 924.5 MB in the beginning and 919.1 MB in the end (delta: 5.4 MB). Peak memory consumption was 5.4 MB. Max. memory is 15.3 GB.
 * RCFGBuilder took 744.92 ms. Allocated memory is still 1.0 GB. Free memory was 919.1 MB in the beginning and 822.3 MB in the end (delta: 96.8 MB). Peak memory consumption was 96.8 MB. Max. memory is 15.3 GB.
 * UtopiaLTL2Aut took 48.22 ms. Allocated memory is still 1.0 GB. Free memory was 822.3 MB in the beginning and 818.7 MB in the end (delta: 3.6 MB). Peak memory consumption was 3.6 MB. Max. memory is 15.3 GB.
 * BÃ¼chi Program Product took 1344.09 ms. Allocated memory was 1.0 GB in the beginning and 1.2 GB in the end (delta: 206.6 MB). Free memory was 818.7 MB in the beginning and 1.1 GB in the end (delta: -314.1 MB). Peak memory consumption was 197.4 MB. Max. memory is 15.3 GB.
 * BlockEncodingV2 took 106.95 ms. Allocated memory is still 1.2 GB. Free memory was 1.1 GB in the beginning and 1.1 GB in the end (delta: 57.4 MB). Peak memory consumption was 57.4 MB. Max. memory is 15.3 GB.
 * BuchiAutomizer took 96916.35 ms. Allocated memory was 1.2 GB in the beginning and 4.7 GB in the end (delta: 3.5 GB). Free memory was 1.1 GB in the beginning and 1.3 GB in the end (delta: -210.8 MB). Peak memory consumption was 3.3 GB. Max. memory is 15.3 GB.
 * Results from de.uni_freiburg.informatik.ultimate.buchiprogramproduct:
  - StatisticsResult: Initial property automaton
    2 locations, 3 edges
  - StatisticsResult: Initial RCFG
    1309 locations, 1635 edges
  - StatisticsResult: BuchiProgram size
    3092 locations, 5270 edges
 * Results from de.uni_freiburg.informatik.ultimate.plugins.generator.traceabstraction:
  - StatisticsResult: Constructed decomposition of program
    Your program was decomposed into 39 terminating modules (39 trivial, 0 deterministic, 0 nondeterministic). 39 modules have a trivial ranking function, the largest among these consists of 49 locations.
  - StatisticsResult: Timing statistics
    BÃ¼chiAutomizer plugin needed 96.8s and 40 iterations.  TraceHistogramMax:6. Analysis of lassos took 9.8s. Construction of modules took 61.8s. BÃ¼chi inclusion checks took 20.5s. Highest rank in rank-based complementation 0. Minimization of det autom 39. Minimization of nondet autom 0. Automata minimization 2.0s AutomataMinimizationTime, 38 MinimizatonAttempts, 9923 StatesRemovedByMinimization, 37 NontrivialMinimizations. Non-live state removal took 1.7s Buchi closure took 0.0s. Biggest automaton had 8843 states and ocurred in iteration 36.	Nontrivial modules had stage [0, 0, 0, 0, 0].	InterpolantCoveringCapabilityFinite: 0/0	InterpolantCoveringCapabilityBuchi: 0/0	HoareTripleCheckerStatistics: 77994 SDtfs, 223833 SDslu, 475615 SDs, 0 SdLazy, 1159451 SolverSat, 41457 SolverUnsat, 0 SolverUnknown, 0 SolverNotchecked, 61.8s Time	LassoAnalysisResults: nont0 unkn0 SFLI0 SFLT0 conc0 concLT0 SILN0 SILU39 SILI0 SILT0 lasso0 LassoPreprocessingBenchmarks: LassoTerminationAnalysisBenchmarks: not availableLassoTerminationAnalysisBenchmarks: LassoNonterminationAnalysisSatFixpoint: 0	LassoNonterminationAnalysisSatUnbounded: 0	LassoNonterminationAnalysisUnsat: 0	LassoNonterminationAnalysisUnknown: 0	LassoNonterminationAnalysisTime: 0.0s	
  - AllSpecificationsHoldResult: All specifications hold
    Buchi Automizer proved that the LTL property ! ( ( []( (call_totalSupply_StreamProtocol0) ==> ( <>(success_totalSupply_StreamProtocol0) ) ) )) holds
RESULT: Ultimate proved your program to be correct!
Received shutdown request...
